<?xml version="1.0" encoding="UTF-8"?>
<CTHeader webcompat="0" proc_error_correction="0" xRayProject="0" revision="$Id: header.xml,v 1.17 2011-03-10 16:50:56 stefanh Exp $" text_recognition_mode="3" text_recognition_methods="" profile_language="eng">
    <Header threshold="0.800000">
        <PageID>
            <Attributes>
                <HTML3 value="act_tabs,act_treeitem"/>
                <HTML3PagKeyCalls>
                    <act_tabs FunName="get_active_page_tab"/>
                    <act_treeitem FunName="get_active_tree_item"/>
                </HTML3PagKeyCalls>
                <Window value="class,text"/>
            </Attributes>
        </PageID>
        <ContextID object_attribute="" context_attribute_name="" rule="0">
            <Attributes>
                <HTML3 context_parameters="wacenwpb6818"/>
            </Attributes>
        </ContextID>
        <Ident classname="Internet Explorer_TridentDlgFrame" exename="iexplore" urls="" version="" caption="">
            <HTML3Script SAPWebIdent="check_sap_fiori_app()">
// include file: ident_script.js

function check_sap_fiori_app() {
    try {
        if (!window || !window.document || !window.document.body) {
            return false;
        }
        var class_name = window.document.body.getAttribute("class");
        if (class_name.search("sapUiBody") !== -1) {
            return "13";
        }
    } catch (err) {
    }
    return false
}

</HTML3Script>
        </Ident>
    </Header>
    <Global min_w="-1" min_h="-1" max_w="-1" max_h="-1">
        <SAP recursion_level="3" has_context_info="1" find_embedded="0" access_check="0"/>
        <JAVA use_jab_watcher="0" jab_tab_lookuplevel="3" jab_tree_lookuplevel="3" enable_jab_button_handler="0" jab_rerecognition_use_name="0" max_sl_edit_jab_height="0" init_with_setpage="0" jab_generate_path="1" java_rere_use_empty_name="1" java_use_fast_path="0" access_check="0"/>
        <MSAA generate_path="0" max_name_objs="200" msaa_tab_lookuplevel="3" msaa_tree_lookuplevel="3" rerecognition_use_names="0"/>
        <UIAutomation uia_tab_lookuplevel="3" uia_tree_lookuplevel="3" unique_ids="0" rerecognition_use_names="1" uia_generate_path="1" max_name_objs="0"/>
        <UIACOM caching="0" generate_path="1" max_name_objs="200"/>
        <HTML handle_zoom="1" has_context_info="0" batch_rerecognition="0" pgkey_fback="0" set_attrb="0" capture_multiple_dlg="0" ignore_dynamic_ids="1">
            <GlobalScript/>
        </HTML>
        <HTML3 handle_zoom="1" has_context_info="1" has_product_info="1" batch_rerecognition="1" capture_multiple_dlg="0" rlevel="0" ignore_dynamic_ids="1" is_xray_profile="1">
            <GlobalScript>
// include file: ../common/common_script.js

var elem_index_within_frame = -1;
var rerecognized_frame = null;
var current_rerecognition_elem_index = -1;
var capture_multi_dlg = false;
var pagtab_attr = "";
var ignore_dynamic_ids = 1;
var ignore_ids = false;
var xray_project = false;
var wpb_system = "";

// Internet Explorer
var dgo_webcompat = false;
var dgo_zoomlevel = 100;
var dgo_ie_version = -1;
var eep_useInnerText = ":A:TD:SPAN:NOBR:LABEL:STRONG:FONT:B:U:DIV:";

function exception_debugging(e) {
    //alert("exception_debugging:\nName: " + e.name + " Description: " + e.description + "\n\n" + e.stack);//
}

// functions called from processor
// IEBrowser::set_ie_info_
function dgo_set_ie_info(ie_info) {
    return DgoProcessing.set_ie_info(ie_info);
}
// IEBrowser::get_element_info_from_script_
function recognition_process(point_x, point_y, frame_path, gen_path, top_frame_left, top_frame_top) {
    return DgoProcessing.recognition_process(point_x, point_y,
        frame_path, gen_path,
        top_frame_left, top_frame_top);
}
// IEBrowser::GetPointRect
function get_cntrl_rect(point_x, point_y, top_frame_left, top_frame_top) {
    return DgoProcessing.get_cntrl_rect(point_x, point_y, top_frame_left, top_frame_top);
}
// IEBrowser::get_rere_script_ (cnltr_search_on_same_level_, process_path_from_script_)
function rerecognition(eepInput, obj_type, check_names, rere_frame_offset_x, rere_frame_offset_y) {
    return DgoProcessing.rerecognition(eepInput, obj_type, check_names,
        rere_frame_offset_x, rere_frame_offset_y);
}
//IEBrowser::execute_on_frame_
function batch_rerecognition(multipaths, obj_type, check_names, rere_frame_offset_x, rere_frame_offset_y) {
    return DgoProcessing.batch_rerecognition(multipaths, obj_type, check_names,
        rere_frame_offset_x, rere_frame_offset_y);
}
// IEBrowser::exec_script_
function get_system_name() {
    return DgoProcessing.get_system_name();
}
// IEBrowser::GetExpandedRect
function get_control_parent_offset(e, par_level) {
    return DgoProcessing.get_control_parent_offset(e, par_level);
}
// IEBrowser::get_cntxt_script_ (get_cntxt_attr_)
function GetContextAttributes() {
    return DgoProcessing.get_context_attributes();
}
// IEBrowser::resolve_eep_
//function Eep_resolve(eepString, options, check_names) { // HTMLProcessor version 2
//    try {
//        var eep_resolveOptions = {
//            eep_first_text_re: null,
//            eep_use_text: check_names,
//            eep_version: "6.1.1"
//        };
//        var eep = DgoEep(eepString, eep_resolveOptions);
//        var obj = eep.eep_resolve();
//        return (typeof obj === "object" ? obj : null);
//    } catch (err) { }
//    return null;
//}
function Eep_resolve3(eepString, options, check_names) { // HTMLProcessor version 3
    return DgoProcessing.eep_resolve3(eepString, options, check_names);
}
// IEBrowser::set_value_
function dgo_set_value(e, val) {
    return DgoProfile.set_value(e, val);
}
// IEBrowser::get_value_
function dgo_get_value(e) {
    return DgoProfile.get_value(e);
}
// IEBrowser::get_page_attr_ - profile specific
// get_active_tree_item
// get_active_page_tab
// get_active_page_tab_level2
// legacy
function dgo_standard_fieldname(e) {
    return DgoProfile.standard_fieldname(e);
}
function dgo_button_name(e) {
    return DgoProfile.button_name(e);
}
function dgo_inner_text(e) {
    return DgoProfile.inner_text(e);
}
function dgo_fieldname_finder(e) {
    return DgoProfile.fieldname_finder(e);
}
function dgo_font_size(e) {
    return DgoProfile.font_size(e);
}
function dgo_font_family(e) {
    return DgoProfile.font_family(e);
}
function dgo_font_color(e) {
    return DgoProfile.font_color(e);
}
function dgo_bg_color(e) {
    return DgoProfile.bg_color(e);
}

function dgo_get_state(e) {
    return DgoProfile.get_state(e);
}
function dgo_set_state(e, s) {
    return DgoProfile.set_state(e, s);
}
function dgo_get_INPUTradio_or_INPUTcheckbox_fieldname(e) {
    return DgoProfile.get_INPUTradio_or_INPUTcheckbox_fieldname(e);
}
function dgo_RADIO_fieldname(e) {
    return DgoProfile.RADIO_fieldname(e);
}
function dgo_get_combo_button_fieldname(e) {
    return DgoProfile.get_combo_button_fieldname(e);
}
function dgo_SAP_Web_checkbox_state(e) {
    return DgoProfile.SAP_Web_checkbox_state(e);
}
// =====================================================================================
// ====================================== Profile ======================================
// =====================================================================================
var DGO = window.DGO || {};

function extendObj(dst, src) {
    for (var i in src) {
        if (src.hasOwnProperty(i)) dst[i] = src[i];
    }
}
// =================================== Processing functions =================================== //
DGO.BaseProcessing = function () { };
DGO.BaseProcessing.prototype = {
    set_ie_info: function (ie_info) {
        try {
            ie_info = DgoProfile.extract_info_from_string(ie_info, "IEinfo", "={", ";");
            var ie_info_map = DgoProfile.convert_from_string_to_map(ie_info, ",");
            if (ie_info_map.IEversion) dgo_ie_version = parseInt(ie_info_map.IEversion);
            if (ie_info_map.Webcompat) {
                if ("true" === ie_info_map.Webcompat) dgo_webcompat = true;
            }
            if (typeof ie_info_map.CaptureMultipleDlg !== "undefined") {
                if (ie_info_map.CaptureMultipleDlg === "1") capture_multi_dlg = true;
            }
            if (typeof ie_info_map.IgnoreDynamicIds !== "undefined") {
                ignore_dynamic_ids = Number(ie_info_map.IgnoreDynamicIds);
            }
            return true;
        } catch (err) {
            exception_debugging(err);
        }
        return false;
    },
    recognition_process: function (point_x, point_y, frame_path, gen_path, top_frame_left, top_frame_top) {
        try {
            var html_rec_obj = HTMLElementRecognition;//new HTMLElementRecognition();
            html_rec_obj.check_input();
            html_rec_obj.init(point_x, point_y, frame_path, gen_path, top_frame_left, top_frame_top);
            try {
                if (!html_rec_obj.get_element_from_point(point_x, point_y)) {
                    return "";
                }
            } catch (err) { exception_debugging(err); }
            if (html_rec_obj.element === null) return "";

            html_rec_obj.get_element_path();
            html_rec_obj.get_bc_rect();
            //if (html_rec_obj.gen_path === 1) {
            html_rec_obj.get_element_eep();
            //}
            html_rec_obj.element_rect_str = html_rec_obj.execute_self_handler(point_x, point_y, html_rec_obj.element);
            DgoProfile.element_rect = html_rec_obj.element_rect;
            html_rec_obj.object_type = html_rec_obj.object_sub_type ? html_rec_obj.object_sub_type : DgoProfile.elem_xtype(html_rec_obj.element);

            //html_rec_obj.object_type = DgoProfile.elem_xtype(html_rec_obj.element) + html_rec_obj.object_sub_type;
            if (typeof html_rec_obj.element.tagName !== "undefined") {
                return html_rec_obj.recognition_output()/* +"|@|"+ html_rec_obj.get_cnlt_props()*/;
            }
        } catch (err) {
            exception_debugging(err);
            return err.name + "," + err.description + "," + err.number;
        }
        return "";
    },
    get_cntrl_rect: function (point_x, point_y, top_frame_left, top_frame_top) {
        var obj_rect = "";
        try {
            var html_rec_rect = HTMLElementRecognition;//new HTMLElementRecognition();
            html_rec_rect.check_input();
            html_rec_rect.init(point_x, point_y, "", 0, top_frame_left, top_frame_top);
            html_rec_rect.get_element_from_point(point_x, point_y);
            if (!html_rec_rect.element) return "";

            html_rec_rect.get_bc_rect();
            html_rec_rect.element_rect_str = html_rec_rect.execute_self_handler(point_x, point_y, html_rec_rect.element);
            if (typeof html_rec_rect.element.tagName !== "undefined") {
                if (html_rec_rect.object_sub_type === "") {
                    var r = html_rec_rect.element_rect;
                    obj_rect = parseInt(r.left) + "," + parseInt(r.top) + "," + parseInt(r.right) + "," + parseInt(r.bottom);
                } else {
                    obj_rect = html_rec_rect.element_rect_str;
                }
            }
        } catch (err) {
            exception_debugging(err);
            return err.name + "," + err.description + "," + err.number;
        }
        return obj_rect;
    },
    rerecognition: function (eepInput, obj_type, check_names, rere_frame_offset_x, rere_frame_offset_y) {
        try {
            rerecognition_frame_offset_x = rere_frame_offset_x;
            rerecognition_frame_offset_y = rere_frame_offset_y;
            var html_rerec_obj = HTMLElementRerecognition;//new HTMLElementRerecognition();
            if (!html_rerec_obj.check_input(eepInput)) return "";
            html_rerec_obj.init(eepInput, obj_type, check_names);
            if (html_rerec_obj.get_elem_from_index_path()) {
                if (DgoProfile.is_obj_hidden(html_rerec_obj.element)) return 2;
                if (html_rerec_obj.element_path === "") html_rerec_obj.get_element_path();
                html_rerec_obj.get_rect();
                DgoProfile.element_rect = html_rerec_obj.element_rect;
                html_rerec_obj.object_type = html_rerec_obj.object_sub_type ? html_rerec_obj.object_sub_type : DgoProfile.elem_xtype(html_rerec_obj.element);
                return html_rerec_obj.rerecognition_output();
            }
        } catch (err) { exception_debugging(err); }
        return "";
    },
    batch_rerecognition: function (multipaths, obj_type, check_names, rere_frame_offset_x, rere_frame_offset_y) {
        var ret_val = "";
        try {
            var elements = DgoProfile.string_to_map_of_map(multipaths, "|PP|", "|PT|");
            var count = elements.length;
            for (var iter = 0; iter &lt; count; iter++) {
                var ret_status = this.rerecognition(elements[iter][0], elements[iter][1], check_names, rere_frame_offset_x, rere_frame_offset_y);
                if (iter != 0) {
                    ret_val = ret_val + "|+|" + ret_status;
                } else {
                    ret_val = ret_status;
                }
            }
        } catch (err) { exception_debugging(err); }
        return ret_val;
    },
    get_system_name: function () { // dummy
        return false;
    },
    get_control_parent_offset: function (e, par_level) {
        var elem = e;
        var fn = "";
        var level = Number(par_level);
        var r_elem = elem.getBoundingClientRect();
        var parent = elem.parentNode;
        for (var iter = 1; iter &lt; level; iter++) {
            if (parent &amp;&amp; parent.parentNode) parent = parent.parentNode;
        }
        if (parent) {
            var p_elem = parent.getBoundingClientRect();
            fn = (parseInt(r_elem.left) - parseInt(p_elem.left)) + "," + (parseInt(r_elem.top) - parseInt(p_elem.top)) + "," +
                (parseInt(p_elem.right) - parseInt(r_elem.right)) + "," + (parseInt(p_elem.bottom) - parseInt(r_elem.bottom));
        }
        return fn;
    },
    get_context_attributes: function () {
        // Systems = SAP Portal ,SAPGUI for HTML, LSO, CRM, NWBC and NW Enterprise Portal.
        // Return value = Context IDs.
        window.document.body.setAttribute("cntxt_attrs", "", 0);
        try {
            var attrs = DgoProfile.get_parent_system_context_attributes() + DgoProfile.get_child_system_context_attributes();
            if (DgoUtils.is_valid_str(attrs)) return attrs;
            if (TitleContextMap.length) return DgoProfile.cntxt_conf_param_from_TitleContextMap();
        } catch (err) { exception_debugging(err); }
        return "";
    },
    eep_resolve3: function (eepString, options, check_names) {
        var ref_path = "";
        try {
            var eep_resolveOptions = {
                eep_first_text_re: null,
                eep_use_text: check_names,
                eep_version: "6.1.1"
            };
            var eep = DgoEep;
            eep.init(eepString, eep_resolveOptions);
            var obj = eep.eep_resolve();
            if (obj) {
                var tag_coll = window.document.getElementsByTagName(obj.tagName);
                if (tag_coll) {
                    var tag_coll_length = tag_coll.length;
                    for (var i = 0; i &lt; tag_coll_length; i++) {
                        var child = tag_coll.item(i);
                        if (obj === child) {
                            //ref_path = 'window.document.all.tags("' + obj.tagName + '")' + '[' + i + ']'; // document.all deprecated in IE11
                            ref_path = "window.document.getElementsByTagName(\"" + obj.tagName + "\")" + "[" + i + "]";
                            break;
                        }
                    }
                }
            }
            //return typeof obj === "object" ? Eep_getPathString(obj, options_) : "";
        } catch (err) { exception_debugging(err); }
        return ref_path;
    }
};
// ====================================== Base functions ====================================== //
DGO.Base = function () { };

DGO.Base.prototype = {
    check_handler: function (type) {
        var valid_tags = [
            // basic html
            "A",
            "DIV",
            "INPUTbutton", "INPUTpassword", "INPUTradio", "INPUTcheckbox", "INPUTcheckboxOn", "INPUTcheckboxOff", "INPUTtext", "INPUTsubmit",
            "IMGA:", "IMGSPAN:",
            "SPAN", "SELECT",
            "TEXTAREA",
            // common
            "AorderItem", "AindexLink", "ApushButton",
            "AWebguiActiveButton", "AWebguiIconTextButton2002", "AWebguiIconTextButton", "AwebguiMetaMenu",
            "BODY",
            "DIVNewMenuItemHilited", "DIVNewMenuItem", "DIVCalT", "DIVCTLink",
            "HTML",
            "IMGA:advClearButton", "IMGA:WebguiActiveIconButton", "IMGA:WebguiIconTextButton",
            "IMGDIVGridView_MenuButton", "IMGDIVwebguiSearchHelpButton", "IMGDIVwebguiTCSearchHelpButtonfixed", "IMGDIVwebguiTCSearchHelpButton",
            "IMGSPAN:hTBCButtonEnabledUnchecked", "IMGSPAN:WebguiToolbarIconEnabled:f_canc", "IMGSPAN:WebguiToolbarIconEnabled:f_back",
            "IMGSPAN:WebguiToolbarIconEnabled:f_okay", "IMGSPAN:WebguiToolbarIconEnabled:f_endt", "IMGSPAN:WebguiToolbarIconEnabled:f_save",
            "IMGSPAN:WebguiToolbarIconEnabled", "IMGSPANColumnTreeExpOpen:CTLink", "IMGSPANColumnTreeExpClose:CTLink",
            "IMGTDTX_XS", "IMGTDTCSelImageUnselected", "IMGTDTCTopPageA", "IMGTDTCLastPageA", "IMGTDTCPrevPageA", "IMGTDTCNextPageA",
            "IMGTDTCPrevRowA", "IMGTDTCNextRowA", "IMGTDTCSelImageSelected", "IMGTDWebguiModalTitleBarXA", "IMGTDWebguiModalTitleBarXI",
            "IMGTDGridViewMarkAllHeader", "IMGTDPULLDOWN-TABSTRIP", "IMGTDwebguiTSForwardA", "IMGTDwebguiTSBackA", "IMGTDwebguiMetaMenu",
            "IMGTDListItem-open", "IMGTDListItem-closed", "IMGTDListItem-leaf", "IMGTDWebguiMessageLine",
            "IMGTDINPUTX", "IMGTDINPUT",
            "INPUTtextplusvalue",
            "OpenValueHelp",
            "SAP_EA_Menu",
            "SPANnoneditinputHighlighted", "SPANnoneditinput", "SPANsapEdfTxtEnbl sapEdfSpanEnbl", "SPAN:urTrcTitHdr",
            "SPANWebguiStatusBarFont", "SPANCTLink", "SPANlabelTable", "SPANlsButton__text urBtnCntTxt", "lsButton__text urBtnCntTxt lsButton--overflow",
            "TDwebguiTSTextDesel", "TDVSlider", "TDListItem", "TDalvc", "TDCalM", "TDWebguiMessageLine", "TDNewMenuCaption",
            "TDNewMenuItemFont", "TDpushButton", "TDsearchHelpResultBody", "THTCColumnTitleSelectable", "DIVWorkcenterStandard", "DIVTabText",
            "IMGAurImgBtn:urBtnStd", "SPAN:urBtnStd"
        ];
        return DgoUtils.is_in_array(type, valid_tags);//valid_tags.indexOf(type) &gt;= 0;
    },
    convert_to_compat: function (type) {
        switch (type) {
            case "INPUTsubmit":
            case "SPANlsButton__text urBtnCntTxt":
            case "lsButton__text urBtnCntTxt lsButton--overflow":
                return "INPUTbutton";
            case "SPAN":
                return "A";
            case "ApushButton":
            case "AindexLink":
                return "AWebguiActiveButton";
            case "IMGA:advClearButton":
            case "IMGA:WebguiActiveIconButton":
                return "IMGA:";
            case "IMGSPAN:hTBCButtonEnabledUnchecked":
                return "IMGSPAN:";
            case "IMGSPAN:WebguiToolbarIconEnabled:f_endt":
                return "IMGSPAN:WebguiToolbarIconEnabled:f_canc";
            case "IMGTDINPUT ":
            case "IMGSPANurImgCbgImg urV:urImgCbgWhl1":
                return "IMGTDINPUT";
            case "INPUTtexturBorderBox lsEdf2HlpRadius lsEdf3HlpBtn lsEdf3HlpBtnDate urEdfVAlign lsEdf3HlpBtnFocus":
            case "INPUTtexturBorderBox lsEdf2HlpRadius lsEdf3HlpBtn lsEdf3HlpBtnDate urEdfVAlign lsEdf3HlpBtnHv lsEdf3HlpBtnHvDate":
                return "INPUTtexturBorderBox lsEdf3HlpBtn lsEdf3HlpBtnDate";
            case "IMGSPANurNoUserSelect urCImgOn urCImgOnHover:urCLbl urCl1 ":
            case "IMGSPANurNoUserSelect urCImgOff lsCWhlTbl urCImgOffHover:urCLbl":
                return "INPUTcheckboxOff";
            case "SPANnoneditinputHighlighted":
            case "SPANnoneditinput":
                return "TDsearchHelpResultBody";
            case "IMGTDTCSelImageSelected":
            case "TDGridViewMarkCell":
                return "IMGTDTCSelImageUnselected";
            case "IMGTDWebguiModalTitleBarXI":
                return "IMGTDWebguiModalTitleBarXA";
            case "TDwebguiTSTextDesel":
            case "AWebguiIconTextButton":
            case "AwebguiMetaMenu":
            case "TDtext":
                return "DIVNewMenuItemHilited";
            case "DIVCalT":
            case "DIVurHSpcLrg urHSpcStdImg":
            case "SPANurCLbl urCl1":
            case "DIVnavIcon":
                return "TDCalM";
            case "IMGTD":
            case "TDth-cal-arr-next":
            case "DIVsapUiSearchFieldIco":
            case "SPANIconArrowOpen textIcon":
                return "TDnavPanExpIco";
            case "Ath-menu-link":
            case "SPANlsMenuItemHover":
                return "SPANurMenuItemTxtStdHover";
            case "INPUTtextth-if th-if-icon th-ip-onfocus":
            case "INPUTtexturCoB2TxtDdl lsEdf3TxtHlpBtn":
            case "INPUTtexturEdf2TxtRadius urEdf2TxtEnbl urEdf2TxtMono lsEdf3TxtHlpBtn lsEdfLeftBrdRadius urEdf2TxtHv":
            case "INPUTtexturEdf2TxtEnbl lsEdf3TxtHlpBtn lsEdfLeftBrdRadius urEdf2TxtWarn urEdf2TxtHv":
                return "INPUTtextth-if th-if-icon";
            case "TDurSTTD urSTTDBdr2 urCursorClickable urSTSStd urSTCl":
            case "Ath-hover-item-text-on":
                return "SPANth-dym-span th-dym-text";
            case "DIVCTLink":
                return "SPANCTLink";
            case "IMGTDurPcExpOpenIco":
            case "DIVOverflowBtn oHover":
                return "IMGTDurPcMenuIcoAll";
            case "INPUTtextlsEdf3HlpBtn lsEdf3HlpBtnF4":
            case "SPANsapEdfHlpF4":
                return "INPUTtextlsEdf3HlpBtn lsEdf3HlpBtnF4 lsEdf3HlpBtnHv";
            case "SPANsapETbvBtnPgDown":
                return "SPANsapETbvBtnDown";
            case "BUTTONsapUiBtn sapUiBtnIconOnly sapUiBtnLite sapUiBtnNoGradient sapUiBtnS sapUiTreeCol sapUiBtnStd":
            case "BUTTONsapUiBtn sapUiBtnIconOnly sapUiBtnLite sapUiBtnNoGradient sapUiBtnS sapUiTreeExp sapUiBtnStd":
            case "IMGAurImgBtn:urNoUserSelect urBtnRadius  urBtnStdWithImg  urBtnStdMnuOnlyImg  urBtnImgBgColor urBtnStd":
            case "IMGAurImgBtn:urBtnStd":
            case "SPAN:urBtnStd":
                return "IMGAurImgBtn:urNoUserSelect urBtnRadius  urBtnStdValign  urBtnStdWithImg  urBtnStdMnuOnlyImg  urBtnImgBgColor urBtnTglStd urBtnStd";
            case "IMGAurBtnMnuIco urBtnMnuIcoHover:urNoUserSelect urBtnRadius  urBtnStdValign urBtnStd":
            case "IMGAurBtnMnuIco:urNoUserSelect urBtnRadius  urBtnStdValign urBtnStd":
                return "SPANth-bt-span";
            case "ACAL_XXS_WEKND":
                return "ACAL_XXS_MAIN";
            case "INPUTtexturEdf2TxtEnbl":
            case "INPUTtexturEdf2TxtEnbl urEdf2TxtHlp":
                return "TDurST3TD urCursorClickable urST3Cl";
            case "Anwbc-HierarchicalBrowserFolderItem":
                return "SPANnwbc-HierarchicalBrowserFolderFolderText";
            default:
                return type;
        }
    },
    elem_xtype: function (e) {
        if (!e) return "";
        var elem = e;
        var tagname = elem.tagName;
        var class_name = elem.className;
        var type = tagname;
        var parent = elem.parentNode;
        var parentcn = parent.className;
        var parenttag = parent.tagName;
        var ntype;

        //if (["B", "U", "EM", "NOBR", "STRONG", "FONT"].indexOf(type) &gt;= 0) {
        if (DgoUtils.is_in_array(type, ["B", "U", "NOBR", "STRONG", "FONT"])) {
            if (parent !== null) {
                elem = parent;
                type = elem.tagName;
            }
        }

        switch (type) {
            case "INPUT":
                type += elem.type;
                tagname = type;
                if (type === "INPUTimage") {
                    ntype = type + "/" + elem.id;
                    type += this.check_handler(ntype) ? "/" + elem.id : "/";
                }
                if (type === "INPUTimage/") {
                    ntype = type + "/" + parent.id;
                    type += this.check_handler(ntype) ? "/" + parent.id : "/";
                }
                if (type === "INPUTtext") type += class_name;
                break;
            case "IMG":
                type += parent.tagName;
                switch (type) {
                    case "IMGA":
                    case "IMGSPAN":
                        type += class_name + ":" + parentcn;
                        if (type === "IMGSPAN:WebguiToolbarIconEnabled") {
                            type += ":" + parent.id;
                            if (this.check_handler(type)) type = "IMGSPAN:WebguiToolbarIconEnabled";
                        }
                        break;
                    case "IMGLABEL":
                        type += class_name;
                        break;
                    case "IMGTD":
                        type += class_name;
                        if (type === "IMGTD") type += parentcn;
                        var prev_sibling = elem.previousSibling;
                        if (type === "IMGTD" &amp;&amp; prev_sibling !== null) type += prev_sibling.tagName;
                        if (type === "IMGTDINPUT" &amp;&amp; prev_sibling !== null) type += prev_sibling.value;
                        if (type.match("IMGTDListItem*")) {
                            type = "IMGTDListItem";
                            var img = elem.href;
                            if (img.match("list.*2_5.*")) {
                                type += "-open";
                            } else if (img.match("list.*2_4.*")) {
                                type += "-closed";
                            } else if (img.match("list.*1_0.*")) {
                                type += "-leaf";
                            }
                            if (type === "IMGTDListItem") type = "IMGTDListItem-leaf"; // assume leaf for everything else
                        }
                        break;
                    case "IMGDIV":
                        if (type === "IMGDIV") type += class_name;
                        if (type === "IMGDIV") type += parentcn;
                        if (type === "IMGDIV") type += parent.id;
                        // Wertehilfe ist etwas anders in tabs und popups
                        if (type.match("IMGDIVwebguiTSSHButton.*") || type.match("IMGDIVwebguiConSHButton.*")) {
                            type = "IMGDIVwebguiSearchHelpButton";
                        }
                        break;
                    case "IMGLABEL":
                        type += class_name;
                        if (type === "IMGLABEL") type += parentcn;
                        break;
                }
                break;
            case "TD":
                type += class_name;

                if (type.match("TDListItem*")) {
                    type = "TDListItem";
                } else if (type.match("TDalvc.*")) {
                    type = "TDalvc";
                } else if (type.match("TDVSlider-*")) {
                    type = "TDVSlider";
                } else if (type.match("TDCalM.*")) {
                    type = "TDCalM";
                } else if (type.match("lsItemlistbox*")) {
                    type = "TDListItem";
                }

                // for TDsearchHelpResultBody
                if (type === "TD") type += parent.parentNode.parentNode.id;
                break;
            case "A":
                type += parentcn === "nwbc-HierarchicalBrowserFolderItem" ? parentcn : class_name;
                break;
            case "DIV":
                type += class_name;
                if (type === "DIV") {
                    if (elem.currentStyle) {
                        type += elem.currentStyle.overflow;
                    }
                } else if (-1 !== type.search("HlpBtnCoB")) {
                    type = "INPUTtexturCoB2Btn";
                } else {
                    var id = elem.id;
                    if (-1 !== id.search("menu")) {
                        type = "SPANbutton_title";
                    }
                }
                break;
            case "SPAN":
                var focus_class = "";
                if (class_name) {
                    type += class_name;
                } else if ((typeof elem.downclass !== "undefined" &amp;&amp; (focus_class = elem.downclass)) ||
                    (typeof elem.hoverclass !== "undefined" &amp;&amp; (focus_class = elem.hoverclass))) {
                    type += focus_class;
                }
                if (type.match("SPANCTLink.*")) {
                    type = "SPANCTLink";
                } else if (type === "SPAN") {
                    type += ":" + parentcn;
                }
                break;
            case "LABEL":
            case "EM":
            case "H2":
            case "LI":
            case "P":
            case "TH":
            case "BUTTON":
                type += class_name;
                break;
            case "BODY":
                if (typeof elem.contentEditable !== "undefined" &amp;&amp; elem.contentEditable === "true") type = "INPUTtexturPagerInput";
                break;
        }

        // do distinguish between SPANurTxtStd in certain TD from SPANurTxtStd in other or none TDs
        if (type === "SPANurTxtStd") {
            if (parentcn === "urSTTD urSTTDBdr2 urCursorClickable urSTSStd urSTCl") {
                type = "SPANurTxtStd_TDurSTTD urSTTDBdr2 urCursorClickable urSTSStd urSTCl";
            }
        }
        // to identify a checked checkbox
        if (type === "IMGLABELurCImgOn") {
            if (parentcn === "urCLbl urCl1") type = "cb_IMGLABELurCImgOn";
        }
        // to identify a unchecked checkbox
        if (type === "IMGLABELurCImgOff") {
            if (parentcn === "urCLbl urCl1") type = "cb_IMGLABELurCImgOff";
        }

        // InputFields in certain TDs for correct rect and fieldname
        if (type === "INPUTtexturEdf2TxtEnbl") {
            if (parenttag === "TD") type = "INPUTurEdf2TxtEnbl_in_TD";
        }
        type = DgoUtils.trim(type);
        if (type === "IMGAth-ip-img:th-ip-h" &amp;&amp; parent.title &amp;&amp; (-1 !== parent.title.search("Open Input Help"))) {
            type = "INPUTtextlsEdf3HlpBtn lsEdf3HlpBtnF4 lsEdf3HlpBtnHv";
        }

        // fallback to tagname if no special entry found
        if (!this.check_handler(type)) {
            switch (tagname) {
                case "A":
                case "BUTTON":
                case "OPTION":
                case "INPUTtext":
                case "TEXTAREA":
                case "DIV":
                    type = tagname;
                    break;
                case "IMG":
                    type = "IMGA:";
                    break;
                case "SPAN":
                    type = "A";
                    break;
                case "BODY":
                case "HTML":
                    break;
                default:
                    type = "A";
                    break;
            }
        }

        type = this.convert_to_compat(type);
        //alert(type);
        //alert(e.outerHTML);
        return type;
    },
    get_info: function (e) {
        var l = 0;
        var t = 0;
        var c = e;
        var txt = "";

        if (e.tagName != "SELECT") txt = e.innerText;

        while (c &amp;&amp; typeof c.offsetLeft !== "undefined") {
            l += c.offsetLeft;
            t += c.offsetTop;
            c = c.offsetParent;
        }

        return { l: l, t: t, w: e.offsetWidth, tag: e.tagName, text: txt };
    },
    get_fn: function (e, x_item, y_item, w_item, flag) {
        if (e === null) return null;

        var s_label = this.get_info(e);
        var fn = s_label.text;
        if (typeof fn === "undefined" || fn === "" || fn === " ") return null;

        var x_label = s_label.l;
        var y_label = s_label.t;
        //var tag = s_label.tag;

        if (typeof flag !== "undefined" &amp;&amp; flag === "right") {
            if (x_item &gt; x_label) return null;
        } else if (x_item &lt; x_label) {
            return null;
        } else if (x_label &gt; 10 + x_item + w_item) {
            return null;
        }

        if (y_label &gt; y_item + 14) return null;
        //if (tag === "SELECT")  return null;

        if (fn.charAt(0) === "*") fn = fn.substr(1);
        if (fn.substr(fn.length - 1, 1) === ":") fn = fn.substr(0, fn.length - 1);
        fn = fn.fast_trim();
        return this.valid_string(fn) &amp;&amp; isNaN(fn)
            ? fn
            : null;
    },
    check_rect_boundry_conditions: function (e, fn_e, flag) {
        if (!this.check_element(fn_e)) return false;
        try {
            var r_e = e.getBoundingClientRect();
            var r_fn_e = fn_e.getBoundingClientRect();
            var h_e = (parseInt(r_e.bottom) - parseInt(r_e.top));
            var h_fn_e = (parseInt(r_fn_e.bottom) - parseInt(r_fn_e.top));

            if (flag === "left" &amp;&amp; (parseInt(r_fn_e.right) &lt;= parseInt(r_e.right)) &amp;&amp; ((h_e * 3) &gt; h_fn_e)) {
                return true;
            }
            if (flag === "top" &amp;&amp; (parseInt(r_fn_e.bottom) &lt;= parseInt(r_e.top))) {
                return true;
            }
            if (flag === "right" &amp;&amp; (parseInt(r_e.right) &lt;= parseInt(r_fn_e.left)) &amp;&amp; ((h_e * 3) &gt; h_fn_e)) {
                return true;
            }
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_fn_from_pos: function (doc, start_x, start_y, delta_x, delta_y, iterations, s_item, e, flag) {
        if (doc === null) return null;
        var fn = null;
        var it = 0;
        var fn_e = null;
        var x_item = s_item.l;
        var y_item = s_item.t;
        var w_item = s_item.w;

        do {
            fn_e = doc.elementFromPoint(start_x, start_y);
            if (fn_e &amp;&amp; !this.is_valid_control_tagname(fn_e) &amp;&amp; this.is_valid_fn_element(fn_e, flag)) {
                if (this.check_rect_boundry_conditions(e, fn_e, flag)) {
                    fn = this.get_fn(fn_e, x_item, y_item, w_item, flag);
                    if (!this.is_valid_fieldname(fn)) fn = "";
                }
            }

            try {
                if (fn_e &amp;&amp; (fn_e.tagName === "INPUT") &amp;&amp; (fn_e.type === "text") &amp;&amp; (flag === "left")) {
                    var rect = fn_e.getBoundingClientRect();
                    if (rect) {
                        start_x = parseInt(rect.left) - 5;
                    }
                }
            } catch (err) { exception_debugging(err); }

            start_x += delta_x;
            start_y += delta_y;

            it++;
        } while (fn_e !== null &amp;&amp; !this.valid_string(fn) &amp;&amp; start_x &gt; 0 &amp;&amp; start_y &gt; 0 &amp;&amp; it &lt; iterations);

        if ((e.tagName === "TEXTAREA") &amp;&amp; fn_e &amp;&amp; fn_e.children &amp;&amp; (fn_e.children.length &gt; 1)) {
            return "";
        }
        return this.valid_string(fn) ? fn : null;
    },
    get_doc_from_elem: function (e) {
        if (!e) return null;
        try {
            if (typeof e.document !== "undefined") return e.document;
            if (typeof e.ownerDocument !== "undefined") return e.ownerDocument;
        } catch (err) { exception_debugging(err); }
        return null;
    },
    get_elem_offset: function (e) {
        var l = 0;
        var t = 0;
        //var my_e = e;
        //var doc = window.document;
        var r = e.getBoundingClientRect();

        l = parseInt(r.left);
        t = parseInt(r.top);

        return { l: l, t: t };
    },
    get_fn_from_left_if_cnlt_present: function (e, no_of_times_travers) {
        if (typeof no_of_times_travers === "undefined") no_of_times_travers = 5;
        var doc = this.get_doc_from_elem(e);
        if (!doc) return "";

        var fn = "";
        var elem_offset = this.get_elem_offset(e);
        var s_item = this.get_info(e);
        var it = 0;
        var fn_e = null;
        var x_item = s_item.l;
        var y_item = s_item.t;
        var w_item = s_item.w;
        var start_x = elem_offset.l - 10;
        var start_y = elem_offset.t + e.offsetHeight / 2;
        var delta_x = -10;
        var delta_y = 0;
        do {
            fn_e = doc.elementFromPoint(start_x, start_y);
            if (fn_e &amp;&amp; fn_e.tagName === "INPUT" &amp;&amp; fn_e.type === "text") {
                var rect = fn_e.getBoundingClientRect();
                start_x = parseInt(rect.left);
                start_y = parseInt(rect.top) + (parseInt(rect.bottom) - parseInt(rect.top)) / 2;
            }
            if (fn_e &amp;&amp; this.check_rect_boundry_conditions(e, fn_e, "left")) {
                fn = this.get_fn(fn_e, x_item, y_item, w_item, "left");
                if (!this.is_valid_fieldname(fn)) fn = "";
            }
            start_x += delta_x;
            start_y += delta_y;
            it++;
        } while (fn_e !== null &amp;&amp; !this.valid_string(fn) &amp;&amp; (start_x &gt; 0) &amp;&amp; (start_y &gt; 0) &amp;&amp; (it &lt; no_of_times_travers));

        return this.valid_string(fn) &amp;&amp; isNaN(fn) ? fn : "";
    },
    get_fn_left: function (e, no_of_times_travers, no_of_travers_done) {
        if (typeof no_of_times_travers === "undefined") no_of_times_travers = 5;
        var doc = this.get_doc_from_elem(e);
        if (!doc) return "";

        var temp = typeof no_of_travers_done !== "undefined" ? no_of_travers_done * 10 : 0;
        var elem_offset = this.get_elem_offset(e);
        var fn = this.get_fn_from_pos(doc, elem_offset.l - 10 - temp,
            elem_offset.t + e.offsetHeight / 2,
            -10, 0, no_of_times_travers,
            this.get_info(e), e, "left");
        if (!DgoUtils.is_valid_str(fn) &amp;&amp; (e.tagName === "TEXTAREA")) {
            fn = this.get_fn_left_top_corner(e, 10);
        }
        return isNaN(fn) ? fn : "";
    },
    get_fn_left_top_corner: function (e, no_of_times_travers, no_of_travers_done) {
        if (typeof no_of_times_travers === "undefined") no_of_times_travers = 5;
        var doc = this.get_doc_from_elem(e);
        if (!doc) return "";

        var temp = typeof no_of_travers_done !== "undefined" ? no_of_travers_done * 10 : 0;
        var elem_offset = this.get_elem_offset(e);
        var fn = this.get_fn_from_pos(doc, elem_offset.l - 10 - temp, elem_offset.t + 5,
            -10, 0, no_of_times_travers, this.get_info(e), e, "left");
        return isNaN(fn) ? fn : "";
    },
    get_fn_right: function (e, no_of_times_travers, no_of_travers_done) {
        if (typeof no_of_times_travers === "undefined") no_of_times_travers = 5;
        var doc = this.get_doc_from_elem(e);
        if (!doc) return "";

        //var temp = typeof no_of_travers_done !== "undefined" ? no_of_travers_done * 10 : 0;
        var elem_offset = this.get_elem_offset(e);
        var fn = this.get_fn_from_pos(doc, elem_offset.l + e.offsetWidth + 10,
            elem_offset.t + e.offsetHeight / 2,
            10, 0, no_of_times_travers,
            this.get_info(e), e, "right");   //10
        return isNaN(fn) ? fn : "";
    },
    get_fn_top: function (e, no_of_times_travers, no_of_travers_done) {
        if (typeof no_of_times_travers === "undefined") no_of_times_travers = 5;
        var doc = this.get_doc_from_elem(e);
        if (!doc) return "";

        // var temp = typeof no_of_travers_done !== "undefined" ? no_of_travers_done * 10 : 0;
        var elem_offset = this.get_elem_offset(e);
        var fn = this.get_fn_from_pos(doc, elem_offset.l,
            elem_offset.t - 10,
            0, -10, no_of_times_travers,
            this.get_info(e), e, "top");
        return isNaN(fn) ? fn : "";
    },
    get_elem_index: function (e) {
        var parent = e.parentElement;
        if (e === null || parent === null) return -1;

        for (var i = 0; i &lt; parent.children.length; i++) {
            if (parent.children.item(i) === e) return i;
        }
        return -1;
    },
    get_distant_child: function (root, r3, r2, r1) {
        if (root === null || r3 &lt; 0 || r2 &lt; 0 || r1 &lt; 0) return null;

        if (root.children.length &lt;= r3) return null;

        var e = root.children.item(r3);
        if (e.children.length &lt;= r2) return null;

        e = e.children.item(r2);
        if (e.children.length &lt;= r1) return null;

        return e.children.item(r1);
    },
    get_control_fn_from_point_traverse: function (e) {
        var fn = "";
        if ("radio" === e.type || "checkbox" === e.type) {
            if (!(fn = this.get_fn_right(e, 15))) {
                fn = this.get_fn_left(e, 5);
                return fn;
            }
        } else {
            if (fn = this.get_fn_left(e, 12)) return fn;
            if (fn = this.get_fn_top(e, 5)) return fn;
            if (fn = this.get_fn_left(e, 20, 12)) return fn;
        }
        return "";
    },
    get_control_fieldname: function (e) {
        if (!this.check_element(e)) return "";
        var field_name = "";
        try {
            var type = e.type;
            switch (e.tagName) {
                case "INPUT":
                    if ("radio" === type || "checkbox" === type) {
                        field_name = this.get_INPUTradio_or_INPUTcheckbox_fieldname(e);
                    } else if ("text" === type || "textarea" === type || "password" === type || "file" === type) {
                        field_name = this.get_INPUTtext_or_INPUTpassword_fieldname(e);
                    }
                    break;
                case "SELECT":
                    field_name = this.get_SELECT_fieldname(e);
                    break;
                case "TEXTAREA":
                    field_name = this.get_INPUTtext_or_INPUTpassword_fieldname(e);
                    break;
            }
            if (null === field_name || " " === field_name || "" === field_name) field_name = this.get_control_parent_caption(e);
            if (!this.is_valid_fieldname(field_name)) field_name = "";
        } catch (err) {
            exception_debugging(err);
            return "";
        }
        return typeof field_name !== "undefined" ? field_name : "";
    },
    get_INPUTradio_or_INPUTcheckbox_fieldname: function (e) {
        var res_text = "";
        try {
            if (("" !== (res_text = this.get_sibling_inner_text(e))) ||
                ("" !== (res_text = this.get_fn_right(e, 15))) ||
                ("" !== (res_text = this.get_fn_left(e, 5))) ||
                ("" !== (res_text = this.get_text_from_child(e)))) { }
            if ("" === res_text &amp;&amp; e.nextSibling) {
                res_text = e.nextSibling.data ? e.nextSibling.data : e.nextSibling.nodeValue;
            }
        } catch (err) {
            exception_debugging(err);
            return "";
        }
        return (typeof res_text !== "undefined" &amp;&amp; res_text !== null) ? res_text : "";
    },
    get_INPUTtext_or_INPUTpassword_fieldname: function (e) {
        var res_text = "";
        //var sibling = "";
        try {
            if (("" !== (res_text = this.get_text_from_child(e))) ||
                ("" !== (res_text = this.get_control_fn_from_point_traverse(e)))) { }
        } catch (err) {
            exception_debugging(err);
            return "";
        }
        return typeof res_text !== "undefined" ? res_text : "";
    },
    get_SELECT_fieldname: function (e) {
        var res_text = "";
        try {
            if (("" !== (res_text = this.get_sibling_inner_text(e))) ||
                ("" !== (res_text = this.get_text_from_child(e))) ||
                ("" !== (res_text = this.get_control_fn_from_point_traverse(e))) ||
                ("" !== (res_text = this.get_fn_right(e)))) { }
        } catch (err) {
            exception_debugging(err);
            return "";
        }
        return typeof res_text !== "undefined" ? res_text : "";
    },
    get_checkbox_fieldname: function (e) {
        var res_text = "";
        try {
            if (("" !== (res_text = this.get_fn_right(e, 15))) ||
                ("" !== (res_text = this.get_fn_left(e, 5)))) { }
        } catch (err) { exception_debugging(err); }
        return typeof res_text !== "undefined" ? res_text : "";
    },
    get_combo_button_fieldname: function (e) {
        var res_text = "";
        try {
            var doc = this.get_doc_from_elem(e);
            if (!doc) return res_text;

            var elem_offset = this.get_elem_offset(e);
            var left_ctl_x = elem_offset.l - 10;
            var left_ctl_y = elem_offset.t + e.offsetHeight / 2;
            var left_ctl = doc.elementFromPoint(left_ctl_x, left_ctl_y);
            if (left_ctl) res_text = this.get_SELECT_fieldname(left_ctl);
            if (left_ctl &amp;&amp; !this.is_valid_fieldname(res_text)) {
                res_text = EepUtils.Eep_getFirstTextNodeValue_(left_ctl, 50, false);
            }
        } catch (err) {
            exception_debugging(err);
            return "";
        }
        return typeof res_text !== "undefined" ? res_text : "";
    },
    check_element: function (e) {
        try {
            return this.get_doc_from_elem(e);
        } catch (err) { exception_debugging(err); }
        return false;
    },
    check_id: function (e) {
        try {
            if (typeof e.id === "undefined" || e.id === "" || e.id === " ") return false;
        } catch (err) {
            exception_debugging(err);
            return false;
        }
        return true;
    },
    check_name: function (e) {
        try {
            if (typeof e.name === "undefined" || e.name === "" || e.name === " ") return false;
        } catch (err) {
            exception_debugging(err);
            return false;
        }
        return true;
    },
    get_sibling_inner_text: function (e) {
        try {
            var sibling = e.nextSibling;
            var id = e.id;
            if (sibling !== null &amp;&amp; this.check_id(e)) {
                var sibling_tag = sibling.tagName;
                var sibling_id = sibling.htmlFor;
                if (typeof sibling_tag === "undefined" || typeof sibling_id === "undefined") return "";
                if ("LABEL" === sibling_tag &amp;&amp; id === sibling_id) return sibling.innerText;
            }
        } catch (err) { exception_debugging(err); }
        return "";
    },
    get_text_from_child: function (e) {
        try {
            var parent = e.parentNode;
            if (!parent) return "";

            var label_coll = parent.getElementsByTagName("LABEL");
            var count = label_coll.length;
            if (0 === count) {
                if (!parent.parentElement) return "";

                label_coll = parent.parentElement.getElementsByTagName("LABEL");
                count = label_coll.length;
                if (0 === count) return "";
            }
            for (var i = 0; i &lt; count; i++) {
                var child_elem = label_coll[i];
                var child_id = child_elem.htmlFor;

                if ((this.is_valid_fieldname(child_id) &amp;&amp; this.is_valid_fieldname(e.id) &amp;&amp; (child_id === e.id)) ||
                    (this.is_valid_fieldname(child_id) &amp;&amp; this.is_valid_fieldname(e.name) &amp;&amp; (child_id === e.name))) {
                    return child_elem.innerText;
                }
            }
        } catch (err) { exception_debugging(err); }
        return "";
    },
    get_control_parent_caption: function (e) {
        var elem = e;
        var it = 0;
        var r_elem = elem.getBoundingClientRect();
        try {
            do {
                var parent = elem.parentNode;
                if (!parent) return "";

                var label_coll = parent.getElementsByTagName("LABEL");
                if (!label_coll) return "";

                var label_child = label_coll.length;
                if (1 === label_child) {
                    var r_label = label_coll[0].getBoundingClientRect();
                    return parseInt(r_elem.bottom) &gt; parseInt(r_label.top) ? label_coll[0].innerText : "";
                } else if (label_child &gt; 1) {
                    break;
                }
                elem = parent;
                it++;
            } while (it &lt; 3);
        } catch (err) { exception_debugging(err); }
        return "";
    },
    get_netwvr_radio_fn: function (e) {
        var doc = this.get_doc_from_elem(e);
        if (!doc) return "";
        var fn = "";
        var iterations = 5;
        try {
            var elem_offset = this.get_elem_offset(e);
            var start_x = elem_offset.l + e.offsetWidth + 10;
            var start_y = elem_offset.t + e.offsetHeight / 2;
            var fn_e = null;
            do {
                fn_e = doc.elementFromPoint(start_x, start_y);
                fn = this.get_info(fn_e).text;
                start_x += 10;
                start_y += 0;
                iterations--;
            } while (fn_e !== null &amp;&amp; this.valid_string(fn) &amp;&amp; start_x &gt; 0 &amp;&amp; start_y &gt; 0 &amp;&amp; iterations);

            if (!this.valid_string(fn) || !isNaN(fn)) fn = null;
        } catch (err) { exception_debugging(err); }
        return fn;
    },
    is_valid_fieldname: function (field_name) {
        return field_name &amp;&amp; isNaN(field_name) &amp;&amp;
            //[":", " ", "*", ""].indexOf(field_name) === -1 &amp;&amp;
            !DgoUtils.is_in_array(field_name, [":", " ", "*", ""]) &amp;&amp;
            field_name.search("&gt;") === -1 &amp;&amp; field_name.search("&lt;") === -1;
    },
    check_accessKey: function (e) {
        try {
            var inner_txt = e.innerText;
            var p_e;
            if (inner_txt.length === 1) {
                p_e = e.parentElement;
                if (!this.check_element(p_e)) return e;
                var accessKy = p_e.accessKey;
                if (typeof accessKy === "undefined") return e;
                if (inner_txt === accessKy) return p_e;
            }
        } catch (err) { exception_debugging(err); }
        return e;
    },
    is_valid_control_tagname: function (e) {
        try {
            //return ["INPUT", "TEXTAREA", "SELECT", "A"].indexOf(e.tagName) &gt;= 0;
            var valid = DgoUtils.is_in_array(e.tagName, ["INPUT", "TEXTAREA", "SELECT", "A"]);
            if (valid) {
                return true;
            } else if (typeof e.getAttribute("role") != "undefined") {
                valid = DgoUtils.is_in_array(e.getAttribute("role"), ["textbox", "text"]);
            }
            return valid;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    is_valid_fn_element: function (e, flag) {
        try {
            if (flag === "left" &amp;&amp; (e.getElementsByTagName("INPUT").length ||
                e.getElementsByTagName("SELECT").length ||
                e.getElementsByTagName("IMG").length ||
                e.getElementsByTagName("TEXTAREA").length)) {
                return false;
            }
            if (flag === "top" &amp;&amp; (e.getElementsByTagName("TABLE").length ||
                e.getElementsByTagName("IMG").length ||
                e.getElementsByTagName("A").length)) {
                return false;
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_ie_zoom_level: function () {
        try {
            if (-1 === dgo_ie_version) dgo_ie_version = DgoUtils.get_ie_version();
            if (dgo_ie_version === 7) {
                var rect = document.body.getBoundingClientRect();
                dgo_zoomlevel = Math.ceil((parseInt(rect.right) - parseInt(rect.left)) / document.body.clientWidth * 100);
            } else if (dgo_ie_version &gt;= 8) {
                dgo_zoomlevel = Math.ceil(window.screen.deviceXDPI / window.screen.logicalXDPI * 100);
            }
        } catch (err) {
            exception_debugging(err);
            dgo_zoomlevel = 100;
        }
    },
    page_attr_url: function () {
        return document.URL;
    },
    offset_rect: function (source_rect, left, top) {
        var r = {};
        r.left = parseInt(source_rect.left) + parseInt(left);
        r.top = parseInt(source_rect.top) + parseInt(top);
        r.right = parseInt(source_rect.right) + parseInt(left);
        r.bottom = parseInt(source_rect.bottom) + parseInt(top);
        return r;
    },
    convert_from_string_to_map: function (string, delimiter) {
        try {
            if(string !== null){
            var params = string.split(delimiter);
            }           
            var map = {};
            for (var i = 0; i &lt; params.length; i++) {
                var parts = params[i].split(":");
                map[parts[0]] = parts[1].substr(1, parts[1].length - 2);
            }
            return map;
        } catch (err) {
            exception_debugging(err);
            throw err;
        }
    },
    extract_info_from_string: function (str, startToken, middleToken, endToken) {
        try {
            var start_pos = str.search(startToken);
            if (-1 === start_pos) return "";

            start_pos = str.indexOf(middleToken, start_pos);
            var end_pos = str.indexOf(endToken, start_pos);
            var res = str.substring(start_pos + 2, end_pos - 1);
            return isNaN(res) ? res : Number(res);
        } catch (err) {
            exception_debugging(err);
            throw err;
        }
    },
    set_state: function (element, state) {
        try {
            if (typeof element.disabled !== "undefined") {
                element.disabled = state;
                return 1;   // true
            }
        } catch (err) {
            exception_debugging(err);
            return -1;       // "exception";
        }
        return 0;           // false
    },
    get_state: function (e) {
        var state = "unchecked";
        if (e !== null &amp;&amp; e.tagName === "INPUT" &amp;&amp; (e.type === "radio" || e.type === "checkbox")) {
            if (e.checked) state = "checked";
            return state;
        }
        var role = DgoUtils.get_role(e);
        if (role === "checkbox" || role === "radio") {
            if (e.getAttribute("aria-checked") === "true") state = "checked";
            return state;
        }

        var p_e = e.parentNode;
        if (p_e &amp;&amp; p_e.tagName === "SPAN" &amp;&amp; p_e.role === "checkbox") {
            if (p_e.getAttribute("aria-checked") === "true") state = "checked";
        }
        return state;
    },
    get_properties: function (elem) {
        var name = "";
        var value = "";

        if (elem) {
            value = this.get_value(elem);
            name = this.standard_fieldname(elem);
            if (!DgoUtils.is_valid_str(name)) this.inner_text(elem);
            if (!DgoUtils.is_valid_str(name)) this.button_name(elem);
        }
        return { name: name, value: value };
    },
    string_to_map_of_map: function (string, outer_dlm, inner_dlm) {
        var map = [];
        try {
            if(string !== null){
            var params = string.split(outer_dlm);
            }
            for (var i = 0; i &lt; params.length; i++) {
                var parts = params[i].split(inner_dlm);
                map[i] = [];
                for (var j = 0; j &lt; parts.length; j++) {
                    map[i].push(parts[j]);
                }
            }
        } catch (err) { exception_debugging(err); }
        return map;
    },
    is_obj_hidden: function (obj) {     // IsObjectHidden
        var doc = this.get_doc_from_elem(obj);
        if (!doc) return true;

        var hidden = false;
        if (typeof obj === "object") {
            var frame_rect = doc.body.getBoundingClientRect();
            var obj_rect = obj.getBoundingClientRect();
            if ((parseInt(obj_rect.right) &lt;= parseInt(obj_rect.left)) || (parseInt(obj_rect.bottom) &lt;= parseInt(obj_rect.top))) {
                hidden = true;
            }
            if ((parseInt(obj_rect.bottom) &lt; parseInt(frame_rect.top)) || (parseInt(obj_rect.right) &lt; parseInt(frame_rect.left)) ||
                ((parseInt(obj_rect.top) &gt; parseInt(window.innerHeight)) &amp;&amp; (parseInt(obj_rect.top) &gt; parseInt(frame_rect.bottom))) || (((parseInt(obj_rect.left) &gt; parseInt(window.innerWidth))) &amp;&amp; (parseInt(obj_rect.left) &gt; parseInt(frame_rect.right)))) {
                hidden = true;
            }
        }
        return hidden;
    },
    is_scrollable_element: function (element) {
        if (element === null) return false;
        // Need to add combo also (only multi select)
        switch (element.tagName) {
            case "BODY":
            case "HTML":
            case "DIV":
            case "TEXTAREA":
            case "SECTION":
                return true;
            case "SPAN":
                if (element.className &amp;&amp; -1 !== element.className.search("scroll")) {
                    return true;
                }
                break;
            case "SELECT":
                return element.type === "select-multiple";
            default:
                return false;
        }
    },
    has_scroll: function (element) {
        if (this.is_scrollable_element(element)) {
            var client_h = element.clientHeight;
            var client_w = element.clientWidth;
            if (client_w &lt; 10 &amp;&amp; client_h &lt; 10) return false;
            if (((element.scrollWidth - client_w) &gt; 15) || ((element.scrollHeight - client_h) &gt; 15)) {
                return true;
            }
        }
        return false;
    },
    standard_fieldname: function (e) {
        var fn = "";
        if (fn = this.get_control_fieldname(e)) return fn;
        if (this.is_valid_control_tagname(e)) return "";
        var p = e ? e.parentElement : null;
        var pp = p ? p.parentElement : null;
        var ppp = pp ? pp.parentElement : null;
        if (ppp === null) return "";

        var s_item = this.get_info(e);
        var x_item = s_item.l;
        var y_item = s_item.t;
        var w_item = s_item.w;

        var root = ppp;
        var r3 = this.get_elem_index(pp);
        var r2 = this.get_elem_index(p);
        var r1 = this.get_elem_index(e);

        if (r3 === -1 || r2 === -1 || r1 === -1) return fn;


        var f_e = this.get_distant_child(root, r3 + 2, r2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 1, r2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 1, r2 - 1, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 1, r2 - 2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 2, r2 - 1, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 2, r2 - 2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 3, r2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 1, r2 + 1, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 1, r2 + 2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3, r2 - 1, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3, r2 - 1, r1 - 1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 + 1, r2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3 - 1, r2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3, r2, r1 - 2);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3, r2, r1 - 1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }

        f_e = this.get_distant_child(root, r3, r2, r1);
        if (f_e !== null) {
            if (fn = this.get_fn(f_e, x_item, y_item, w_item)) return fn;
        }
        return "";
    },
    valid_string: function (str) {
        return str &amp;&amp;
            //["", "undefined", " ", "  ", "   ", "    "].indexOf(str) === -1 &amp;&amp;
            !DgoUtils.is_in_array(str, ["", "undefined", " ", "  ", "   ", "    "]) &amp;&amp;
            str.length &lt;= 80;
    },
    inner_text: function (e) {
        try {
            if (e) {
                if (e.children &amp;&amp; e.children.length == 0) {
                    if (e.tagName === "B" &amp;&amp; e.parentElement) {
                        var inner = e.parentElement.innerText;
                        if (typeof inner !== "undefined") return inner;
                    }
                    if (typeof e.innerText !== "undefined") {
                        return "" + e.innerText;
                    }
                } else {
                    var e = EepUtils.Eep_getFirstElementNode_(e);
                    if (e) {
                        if (DgoUtils.is_valid_str(e.innerText)) {
                            return e.innerText;
                        }
                    }
                }
            }
        } catch (err) { exception_debugging(err); }
        return "";
        return "";
    },
    button_name: function (e) {
        var name = "";
        try {
            if (e !== null) {
                if (e.title &amp;&amp; e.title.length &gt; 0) {
                    name = e.title;
                } else if (e.alt &amp;&amp; e.alt.length &gt; 0) {
                    name = e.alt;
                }
            }
        } catch (err) { exception_debugging(err); }

        return typeof name !== "undefined" ? name : "";
    },
    fieldname_finder: function (e) {
        var fieldname = dgo_button_name(e);
        if (!fieldname) {
            fieldname = dgo_inner_text(e);
        }
        return fieldname;
    },
    RADIO_fieldname: function (e, type) {
        var fn = "";
        if (fn = this.get_control_fieldname(e)) return fn;
        var parent = e.parentNode;
        if (type === "INPUTradio") {
            if (e.nextSibling !== null) {
                if (e.nextSibling.nextSibling !== null) {
                    fn = e.nextSibling.nextSibling.innerText;
                } else {
                    fn = parent.innerText;
                }
            } else {
                fn = parent.innerText;
            }
        } else {
            fn = parent.innerText;
        }
        if (!this.valid_string(fn)) {
            if (parent.previousSibling !== null) fn = parent.previousSibling.innerText;
        }
        if (!this.valid_string(fn)) {
            if (parent.nextSibling !== null) fn = parent.nextSibling.innerText;
        }
        if (!this.valid_string(fn)) {
            var p_next_sib = parent.nextSibling;
            if (p_next_sib !== null &amp;&amp; p_next_sib.nextSibling !== null) {
                fn = p_next_sib.nextSibling.innerText;
            }
        }
        if (!this.valid_string(fn)) {
            var p_parent = parent.parentNode;
            if (p_parent !== null &amp;&amp; p_parent.parentNode !== null) {
                var ppp_prev_sib = p_parent.parentNode.previousSibling;
                if (ppp_prev_sib !== null &amp;&amp; ppp_prev_sib.children.length &gt; 0) {
                    fn = ppp_prev_sib.children.item(0).innerText;
                    if (fn.charAt(fn.length - 1) === ":") {
                        fn = fn.substr(0, fn.length - 1);
                    }
                }
            }
        }

        return fn !== "undefined" &amp;&amp; fn.length &lt;= 80 ? fn : "";
    },
    font_weight: function (e) {
        return (e &amp;&amp; e.currentStyle &amp;&amp; e.currentStyle.fontWeight &gt;= 600) ? 1 : 0;
    },
    font_size: function (e) {
        try {
            if (!this.check_element(e)) return -1;
            var fn_size = "";
            if (e.currentStyle &amp;&amp; e.currentStyle.fontSize) fn_size = this.get_font_size(e.currentStyle.fontSize, false);
            if ((-1 === fn_size) &amp;&amp; e.runtimeStyle &amp;&amp; e.runtimeStyle.fontSize) fn_size = this.get_font_size(e.runtimeStyle.fontSize, false);
            return fn_size;
        } catch (err) { exception_debugging(err); }
        return -1;
    },
    // units:
    // -pt: points  the points used by CSS are equal to 1/72nd of 1in.
    // -pc: picas  1pc is equal to 12pt.
    // -px: pixel units  1px is equal to 0.75pt.
    get_absolute_font_size: function (size) {
        try {
            if (size.indexOf("pt") !== -1) {
                return parseInt(size);
            } else if (size.indexOf("px") !== -1) {
                return Math.round(parseInt(size) * 0.75);
            }
        } catch (err) { exception_debugging(err); }
        return -1;
    },
    get_relative_font_size: function (size) {
        try {
            if (size.indexOf("em") !== -1) {
                return parseFloat(size);
            } else if (size.indexOf("%") !== -1) {
                return parseFloat(size) / 100;
            }
        } catch (err) { exception_debugging(err); }
        return 1;
    },
    get_font_size: function (size, body_elm) {
        if (size.length &lt;= 0) return -1;
        try {
            var abs_font = this.get_absolute_font_size(size);
            if (abs_font !== -1) {
                return abs_font;
            } else {
                var rel_font = this.get_relative_font_size(size);
                var base_font = 0;
                var cur_style = window.document.documentElement.currentStyle;
                if (body_elm) {
                    if (cur_style &amp;&amp; cur_style.fontSize) base_font = parseInt(cur_style.fontSize);
                } else {
                    base_font = this.get_font_size(cur_style.fontSize, true);
                }
                return Math.round(base_font * rel_font);
            }
        } catch (err) { exception_debugging(err); }
        return -1;
    },
    font_family: function (e) {
        if (e &amp;&amp; e.currentStyle) {
            return "" + e.currentStyle.fontFamily;
        } else if (e &amp;&amp; e.runtimeStyle) {
            return "" + e.runtimeStyle.fontFamily;
        } else {
            return "";
        }
    },
    font_color: function (e) {
        if (e &amp;&amp; e.currentStyle) {
            var font_color = e.currentStyle.color;
            return -1 === font_color.search(/rgb/i) ? "" + e.currentStyle.color : DgoUtils.rgb_to_hex(font_color);
        }
        return "";
    },
    bg_color: function (e) {
        return e &amp;&amp; e.currentStyle &amp;&amp; e.currentStyle.backgroundColor !== "" ?
            "#" + e.currentStyle.backgroundColor :
            "#ffffff";
    },
    get_value: function (e) {
        var res = "";
        if (e) {
            if (e.tagName === "SELECT" &amp;&amp; e.options) {
                for (var i = 0; i &lt; e.options.length; i++) {
                    if (e.options[i].selected) res += "{*}";
                    res = res + e.options[i].text + "\n";
                }
            } else if (e.tagName === "INPUT" &amp;&amp; e.value) {
                res = e.value;
            } else if (e.tagName === "TEXTAREA" &amp;&amp; e.value) {
                res = e.value;
            } else if (e.tagName === "BODY" &amp;&amp; typeof e.contentEditable !== "undefined" &amp;&amp; e.contentEditable === "true") {
                res = e.innerText;
            }
        }
        return res;
    },
    set_value: function (e, val) {
        var res = "&lt;error&gt;";
        if (e) {
            if (e.tagName === "SELECT" &amp;&amp; e.options) {
                for (var i = 0; i &lt; e.options.length; i++) {
                    if (e.options[i].text === val) {
                        e.options[i].selected = true;
                        e.onchange();
                        res = "ok";
                        break;
                    }
                }
            } else if (e.tagName === "INPUT") {
                if (e.type === "radio" || e.type === "checkbox") {
                    if (val === "checked") {
                        e.checked = true;
                    } else if (val === "unchecked") {
                        e.checked = false;
                    }
                } else {
                    e.value = val;
                }
                res = "ok";
            }
        }
        return res;
    },
    inner_html_text: function (e) {
        var res = "";
        var innertext = e.innerText.toLowerCase();
        var innerhtml = e.innerHTML.toLowerCase();
        if (innertext) {
            var result = innerhtml.indexOf(innertext);
            if (result &gt; -1) {
                res = e.innerHTML.substring(result, result + innertext.length)
            } else {
                res = e.innerText;
            }
        } else {
            res = e.innerHTML;
        }
        return res.trim();
    }
};
// =====================================================================================
// =====================================================================================

// ====================================== String prototype extensions ====================================== //
var String_ltrimRE_ = /^[ \r\n\t\xA0]*(.*$)/m;
var String_rtrimRE_ = /[ \r\n\t\xA0]*$/m;

String.prototype.ltrim = function () {
    return String_ltrimRE_.exec(this)[1];
};
String.prototype.rtrim = function () {
    var match = String_rtrimRE_.exec(this);
    return this.substr(0, this.length - match[0].length);
};
String.prototype.alltrim = function () {
    var ret_val = this.ltrim();
    return ret_val.rtrim();
};
String.prototype.fast_trim = function () {
    return this.replace(/^ */, "").replace(/ *$/, "");
};
String.prototype.asJSstring = function () {
    var ret_val = new String(this);
    ret_val = ret_val.replace(/[\\]/g, "\\\\");
    ret_val = ret_val.replace(/[""]/g, "");
    ret_val = ret_val.replace(/[\n]/g, "\\n");
    ret_val = ret_val.replace(/[\r]/g, "\\r");
    ret_val = ret_val.replace(/[\t]/g, "\\t");
    ret_val = ret_val.replace("'", "");
    ret_val = ret_val.replace(":", "");
    return "\"" + ret_val + "\"";
};

if (!String.prototype.trim) {
    (function () {
        // Make sure we trim BOM and NBSP
        var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        String.prototype.trim = function () {
            return this.replace(rtrim, '');
        };
    })();
}
// =============================================== RECOGNITION ===============================================
var delimiter = "|##|";
var elem_with_frame_path = "window";

DGO.BaseHTMLElementRecognition = function () { };

DGO.BaseHTMLElementRecognition.prototype = {
    element_path: "",
    element_index_path: "",
    element_rect: null,
    bc_rect: null,
    element: null,
    eep: "",
    object_type: "",
    object_sub_type: "",
    element_rect_str: "",
    client_x: null,
    client_y: null,
    frame_offset_x: 0,
    frame_offset_y: 0,
    frame_path: "",
    gen_path: 1,
    has_role: false,

    get_cnlt_props: function () {
        try {
            var prop = "fieldname" + "=" + DgoProfile.standard_fieldname(this.element) + "|+|";
            prop += "fieldvalue" + "=" + DgoProfile.get_value(this.element) + "|+|";
            prop += "size" + "=" + DgoProfile.font_size(this.element) + "|+|";
            prop += "fontfamily" + "=" + DgoProfile.font_family(this.element) + "|+|";
            prop += "color" + "=" + DgoProfile.font_color(this.element) + "|+|";
            prop += "bgcolor" + "=" + DgoProfile.bg_color(this.element) + "|+|";
            prop += "innertext" + "=" + DgoProfile.inner_text(this.element);
            return prop;
        } catch (err) { exception_debugging(err); }
        return "";
    },
    check_input: function () {
        return window !== null &amp;&amp; window.document !== null;
    },
    init: function (point_x, point_y, frame_path, gen_path, top_frame_left, top_frame_top) {
        this.gen_path = gen_path;
        this.element_rect = {};
        this.bc_rect = {};
        this.client_x = point_x;
        this.client_y = point_y;
        DgoProfile.get_ie_zoom_level();
        this.frame_path = frame_path;
        elem_with_frame_path = "window";
        this.frame_offset_x = top_frame_left;
        this.frame_offset_y = top_frame_top;
    },
    get_element_from_point: function (point_x, point_y) {
        try {
            var client_x = point_x;
            var client_y = point_y;
            if (Math.abs(dgo_zoomlevel - 100) &gt; 4) {
                client_x = Math.ceil(client_x * 100 / dgo_zoomlevel);
                client_y = Math.ceil(client_y * 100 / dgo_zoomlevel);
            }
            if (!(this.element = window.document.elementFromPoint(client_x, client_y))) return false;

            this.element = DgoProfile.check_accessKey(this.element);
            if (this.element &amp;&amp; this.element.tagName === "B") this.element = this.element.parentElement;
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    exec_on_main_win: function (point_x, point_y) {
        try {
            var client_x = point_x;
            var client_y = point_y;
            if (Math.abs(dgo_zoomlevel - 100) &gt; 4) {
                client_x = Math.ceil(client_x * 100 / dgo_zoomlevel);
                client_y = Math.ceil(client_y * 100 / dgo_zoomlevel);
            }
            if (!(this.element = window.top.document.elementFromPoint(client_x, client_y))) return false;
            this.frame_path = "";
            this.element = DgoProfile.check_accessKey(this.element);
            if (this.element &amp;&amp; this.element.tagName === "B") this.element = this.element.parentElement;
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_element_path: function () {
        try {
            var tagname = this.element.tagName;
            var tag_coll = window.document.getElementsByTagName(tagname);
            if (!tag_coll) return tag_coll;

            var tag_coll_length = tag_coll.length;
            for (var i = 0; i &lt; tag_coll_length; i++) {
                var child = tag_coll.item(i);
                if (this.element === child) {
                    //this.element_path = "window.document.all.tags(\"" + tagname + "\")" + "[" + i + "]";  // document.all deprecated in IE11
                    this.element_path = "window.document.getElementsByTagName(\"" + tagname + "\")" + "[" + i + "]";
                    return true;
                }
            }
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_bc_rect: function () {
        try {
            this.element_rect = this.element.getBoundingClientRect();
            var node = this.element;
            if (node &amp;&amp; node.parentNode) {
                var p_node = node.parentNode;
                var p_elem = p_node;
                if (p_elem &amp;&amp; "clipper" === p_elem.tagName) {
                    if (p_node.parentNode) p_node = p_node.parentNode;
                    this.element_rect = p_node.getBoundingClientRect();
                }
                if (p_elem &amp;&amp; "SPAN" === p_elem.tagName &amp;&amp; "th-bt-span" === p_elem.className) {
                    if (p_node.parentNode) {
                        p_node = p_node.parentNode;
                        if (p_node &amp;&amp; "A" === p_node.tagName &amp;&amp; p_node.className &amp;&amp;
                            -1 !== p_node.className.search("th-bt th-bt")) {
                            this.element_rect = p_node.getBoundingClientRect();
                        }
                    }
                }
            }
            if ((parseInt(this.element_rect.right) - parseInt(this.element_rect.left)) &lt; 3) {
                var r = {};
                r.right = parseInt(this.element_rect.right) + 5;
                r.left = parseInt(this.element_rect.left) - 5;
                r.top = parseInt(this.element_rect.top);
                r.bottom = parseInt(this.element_rect.bottom);
                this.element_rect = r;
                this.element_rect.right = parseInt(this.element_rect.right) + parseInt(5);
                this.element_rect.left = parseInt(this.element_rect.left) - parseInt(5);
                if (this.element_rect.left &lt; 0) {
                    this.element_rect.left = 0;
                }
            }
            if ((parseInt(this.element_rect.bottom) - parseInt(this.element_rect.top)) &lt; 3) {
                var rt = {};
                rt.bottom = parseInt(this.element_rect.bottom) + 5;
                rt.top = parseInt(this.element_rect.top) - 5;
                rt.left = parseInt(this.element_rect.left);
                rt.right = parseInt(this.element_rect.right);
                this.element_rect = rt;
                if (this.element_rect.top &lt; 0) {
                    this.element_rect.top = 0;
                }
            }
            this.element_rect = DgoProfile.offset_rect(this.element_rect, this.frame_offset_x, this.frame_offset_y);
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    execute_self_handler: function (clickptx, clickpty, elem) {
        //these points are wrt client co-ordinate i.e. after offsetting loff_
        //Call dgo_self_handler and update type and rect if applicable
        var ret_val = "nonscrollable";
        if (DgoProfile.is_scrollable_element(elem)) {
            var client_h = elem.clientHeight;
            var client_w = elem.clientWidth;
            if (client_w &lt; 10 &amp;&amp; client_h &lt; 10) return ret_val;
            ret_val = "scrollable";
            var b_rect = elem.getBoundingClientRect();
            b_rect = DgoProfile.offset_rect(b_rect, this.frame_offset_x, this.frame_offset_y);
            clickptx = clickptx + this.frame_offset_x;
            clickpty = clickpty + this.frame_offset_y;
            var scroll_button_size = 30;
            if (-1 === dgo_ie_version) dgo_ie_version = DgoUtils.get_ie_version();
            if (dgo_ie_version &lt; 10) scroll_button_size = 16;
            //var client_l = elem.clientLeft;
            //var client_t = elem.clientTop;
            var scroll_w = elem.scrollWidth;
            var scroll_h = elem.scrollHeight;
            var scroll_l = elem.scrollLeft;
            var scroll_t = elem.scrollTop;
            var fac;
            if (scroll_w &gt; client_w) {
                var hb_rect = {};

                hb_rect.left = b_rect.left;
                hb_rect.top = b_rect.top + client_h;
                hb_rect.right = hb_rect.left + client_w;
                hb_rect.bottom = b_rect.bottom;
                if (hb_rect.left &lt; 0) hb_rect.left = 0;

                if (hb_rect.top == hb_rect.bottom) {
                    hb_rect.right = window.innerWidth;
                    if (hb_rect.right &lt; 0) hb_rect.right = 0;
                    hb_rect.bottom = window.innerHeight;
                }
                if (0 &gt; hb_rect.top) {
                    var top_diff = window.top.innerHeight - window.innerHeight;
                    hb_rect.top = top_diff;
                }
                // if click point falls in scroll area, do the processing otherwise return it
                if (clickpty &gt; hb_rect.top &amp;&amp; clickpty &lt; hb_rect.bottom) {
                    fac = 0.0;
                    if (clickptx &gt; hb_rect.left &amp;&amp; clickptx &lt; (hb_rect.left + scroll_button_size)) {
                        this.object_sub_type = "HScrollBtnL";
                        return hb_rect.left + "," + hb_rect.top + "," + (hb_rect.left + scroll_button_size) + "," + hb_rect.bottom;
                    }
                    if (clickptx &gt; (hb_rect.right - scroll_button_size) &amp;&amp; clickptx &lt; hb_rect.right) {
                        this.object_sub_type = "HScrollBtnR";
                        return (hb_rect.right - scroll_button_size) + "," + hb_rect.top + "," + hb_rect.right + "," + hb_rect.bottom;
                    }
                    hb_rect.left += scroll_button_size;
                    hb_rect.right -= scroll_button_size;
                    if (scroll_h &gt; 0) fac = (client_w - scroll_button_size) / scroll_w;
                    else fac = 1;
                    var hb_wdth = Math.round(fac * (client_w - scroll_button_size));
                    if (scroll_l &gt; 0 &amp;&amp; clickptx &gt; hb_rect.left &amp;&amp; clickptx &lt; (hb_rect.left + Math.ceil(scroll_l * fac))) {
                        this.object_sub_type = "HScrollAreaL";
                        return hb_rect.left + "," + hb_rect.top + "," + (hb_rect.left + Math.round(scroll_l * fac)) + "," + hb_rect.bottom;
                    }
                    hb_rect.left += Math.round(scroll_l * fac);
                    if (hb_rect.right &gt; (hb_rect.left + hb_wdth) &amp;&amp; clickptx &gt; (hb_rect.left + hb_wdth) &amp;&amp; clickptx &lt; hb_rect.right) {
                        this.object_sub_type = "HScrollAreaR";
                        return (hb_rect.left + hb_wdth) + "," + hb_rect.top + "," + hb_rect.right + "," + hb_rect.bottom;

                    } else if (clickptx &gt; hb_rect.left &amp;&amp; clickptx &lt; (hb_rect.left + hb_wdth)) {
                        this.object_sub_type = "HScrollBar";
                        return hb_rect.left + "," + hb_rect.top + "," + (hb_rect.left + hb_wdth) + "," + hb_rect.bottom;
                    }
                }
            }
            if (scroll_h &gt; client_h) {
                var vb_rect = {};
                vb_rect.left = b_rect.left + client_w;
                vb_rect.top = b_rect.top;
                vb_rect.right = b_rect.right;
                vb_rect.bottom = vb_rect.top + client_h;
                if (vb_rect.left == vb_rect.right) {
                    vb_rect.right = window.top.innerWidth;
                    vb_rect.bottom = window.top.innerHeight;
                }
                if (0 &gt; vb_rect.top) {
                    var top_diff = window.top.innerHeight - window.innerHeight;
                    vb_rect.top = top_diff;
                }

                // if click point falls in scroll area, do the processing otherwise return it
                if ((clickptx &gt; vb_rect.left) &amp;&amp; (vb_rect.right &gt; clickptx)) {
                    fac = 0.0;
                    if (clickpty &gt; vb_rect.top &amp;&amp; clickpty &lt; (vb_rect.top + scroll_button_size)) {
                        this.object_sub_type = "VScrollBtnT";
                        return vb_rect.left + "," + vb_rect.top + "," + vb_rect.right + "," + (vb_rect.top + scroll_button_size);
                    }
                    if (clickpty &gt; (vb_rect.bottom - scroll_button_size) &amp;&amp; clickpty &lt; vb_rect.bottom) {
                        this.object_sub_type = "VScrollBtnB";
                        return vb_rect.left + "," + (vb_rect.bottom - scroll_button_size) + "," + vb_rect.right + "," + vb_rect.bottom;
                    }
                    vb_rect.top += scroll_button_size;
                    vb_rect.bottom -= scroll_button_size;
                    if (scroll_h &gt; 0) fac = (client_h - scroll_button_size) / scroll_h;
                    else fac = 1;
                    var vb_hght = Math.round(fac * (client_h - scroll_button_size));
                    if (scroll_t &gt; 0 &amp;&amp; clickpty &gt; vb_rect.top &amp;&amp; clickpty &lt; (vb_rect.top + Math.ceil(scroll_t * fac))) {
                        this.object_sub_type = "VScrollAreaT";
                        return vb_rect.left + "," + vb_rect.top + "," + vb_rect.right + "," + (vb_rect.top + Math.round(scroll_t * fac));
                    }
                    vb_rect.top += Math.round(scroll_t * fac);
                    if (vb_rect.bottom &gt; (vb_rect.top + vb_hght) &amp;&amp; clickpty &gt; (vb_rect.top + vb_hght) &amp;&amp; clickpty &lt; vb_rect.bottom) {
                        this.object_sub_type = "VScrollAreaB";
                        return vb_rect.left + "," + (vb_rect.top + vb_hght) + "," + vb_rect.right + "," + vb_rect.bottom;

                    } else if (clickpty &gt; vb_rect.top &amp;&amp; clickpty &lt; (vb_rect.top + vb_hght)) {
                        this.object_sub_type = "VScrollBar";
                        return vb_rect.left + "," + vb_rect.top + "," + vb_rect.right + "," + (vb_rect.top + vb_hght);
                    }
                }
            }
        }
        return ret_val;
    },
    get_element_eep: function () {
        try {
            var elem_path_webcompat = "";
            if (dgo_webcompat) {
                this.get_element_index_path();
                elem_path_webcompat = this.element_index_path;
            }
            this.eep = "eep_frame=\"" + this.frame_path + "\";eep_simple_path=\"" + elem_path_webcompat +
                "\";" + EepUtils.Eep_generate(this.element) + "client_x=\"" + this.client_x + "\";client_y=\"" + this.client_y + "\";";
            if (this.frame_path === "") this.frame_path = "-1";
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    recognition_output: function () {
        try {
            var obj_rect = this.object_sub_type === "" ?
                parseInt(this.element_rect.left) + "," + parseInt(this.element_rect.top) + "," +
                parseInt(this.element_rect.right) + "," + parseInt(this.element_rect.bottom) :
                this.element_rect_str;
            return ("epath|=|" + this.element_path + delimiter + "type|=|" + this.object_type + delimiter + "rect|=|" + obj_rect + delimiter + "eep|=|" + this.eep);
        } catch (err) { exception_debugging(err); }
        return "";
    },
    get_element_index_path: function () {
        try {
            var element_path = [];
            var delimiter = ":";
            this.get_index_path_recursive(this.element, window.document.body, element_path);
            var length = element_path.length;
            for (var i = 0; i &lt; length; i++) {
                if (i === length - 1) delimiter = "";
                this.element_index_path = this.element_index_path + element_path[i] + delimiter;
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_index_path_recursive: function (element, root, path) {
        try {
            if (root === null) return false;
            if (element === root) return true;
            var collection = root.children;
            if (collection === null) return false;

            var length = collection.length;
            for (var i = 0; i &lt; length; i++) {
                path.push(i);
                var item = collection.item(i);
                if (this.get_index_path_recursive(element, item, path)) return true;
                path.pop(i);
            }
        } catch (err) { exception_debugging(err); }
        return false;
    }
};   // end HTMLElementRecognition.prototype
//===============================================RERECOGNITION===============================================
var rerecognition_frame_offset_x = 0;
var rerecognition_frame_offset_y = 0;

DGO.BaseHTMLElementRerecognition = function () { };

DGO.BaseHTMLElementRerecognition.prototype = {
    recording_element_type: "",
    element_path: "",
    element_index_path: "",
    eep: "",
    element_rect: null,
    element_rect_str: "",
    element: null,
    object_type: "",
    object_sub_type: "",
    client_x: null,
    client_y: null,
    check_names: "",
    recording_element_info_map: null,

    check_input: function (eepInput) {
        return window &amp;&amp; eepInput &amp;&amp; eepInput !== "" &amp;&amp; window.document;
    },
    init: function (eepInput, obj_type, check_names) {
        try {
            this.element_index_path = "";
            this.element_rect_str = "";
            this.object_type = "";
            this.object_sub_type = "";
            this.element = null;
            this.recording_element_type = obj_type;
            elem_index_within_frame = -1;
            this.element_path = DgoProfile.extract_info_from_string(eepInput, "element_path", "=", ";");
            this.client_x = DgoProfile.extract_info_from_string(eepInput, "client_x", "=", ";");
            this.client_y = DgoProfile.extract_info_from_string(eepInput, "client_y", "=", ";");
            var start_pos = eepInput.search("element_path");

            if (-1 === start_pos) this.eep = eepInput;
            else this.eep = eepInput.substring(0, start_pos);

            this.element_rect = {};
            this.check_names = check_names;
            this.recording_element_info_map = {};
            elem_with_frame_path = "window";
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_elem_from_index_path: function () {
        try {
            //this.element = Eep_resolve(this.eep, 0, this.check_names);
            this.element = eval(Eep_resolve3(this.eep, 0, this.check_names));
            if (this.element) {
                this.element_rect_str = this.execute_self_handler(this.recording_element_type, this.element);
                return true;
            }
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_rect: function () {
        try {
            var br = this.element.getBoundingClientRect();
            this.element_rect.left = ((br.left &gt; 0) ? parseInt(br.left) : 0) + parseInt(rerecognition_frame_offset_x);
            this.element_rect.right = parseInt(br.right) + parseInt(rerecognition_frame_offset_x);
            this.element_rect.top = parseInt(br.top) + parseInt(rerecognition_frame_offset_y);
            this.element_rect.bottom = parseInt(br.bottom) + parseInt(rerecognition_frame_offset_y);
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_element_path: function () {
        try {
            var tagname = this.element.tagName;
            if (-1 === elem_index_within_frame) {
                var tag_coll = null;
                tag_coll = window.document.getElementsByTagName(tagname);
                var tag_coll_length = tag_coll.length;
                for (var i = 0; i &lt; tag_coll_length; i++) {
                    var child = tag_coll.item(i);
                    if (this.element === child) {
                        //this.element_path = "window.document.all.tags(\"" + tagname + "\")" + "[" + i + "]";  // document.all deprecated in IE11
                        this.element_path = "window.document.getElementsByTagName(\"" + tagname + "\")" + "[" + i + "]";
                        return true;
                    }
                }
                //this.element_path = "window.document.all.tags(\"" + tagname + "\")" + "[0]";    // document.all deprecated in IE11
                this.element_path = "window.document.getElementsByTagName(\"" + tagname + "\")" + "[0]";
            } else {
                //this.element_path = "window.document.all.tags(\"" + tagname + "\")[" + elem_index_within_frame + "]"; // document.all deprecated in IE11
                this.element_path = "window.document.getElementsByTagName(\"" + tagname + "\")[" + elem_index_within_frame + "]";
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    rerecognition_output: function () {
        var r = this.element_rect;
        var obj_rect = this.object_sub_type === "" ?
            parseInt(r.left) + "," + parseInt(r.top) + "," + parseInt(r.right) + "," + parseInt(r.bottom) :
            this.element_rect_str;
        return ("type=" + this.object_type + delimiter + "rect=" + obj_rect + delimiter + "epath=" + this.element_path);
    },
    execute_self_handler: function (obj_type, elem) {
        var ret_val = "";
        if (DgoProfile.is_scrollable_element(elem)) {
            var sub_type = this.recording_element_type;
            var client_h = elem.clientHeight;
            var client_w = elem.clientWidth;
            var b_rect = elem.getBoundingClientRect();
            b_rect = DgoProfile.offset_rect(b_rect, rerecognition_frame_offset_x, rerecognition_frame_offset_y);
            var scroll_button_size = 30;
            if (-1 === dgo_ie_version) dgo_ie_version = DgoUtils.get_ie_version();
            if (dgo_ie_version &lt; 10) scroll_button_size = 16;

            //var client_l = elem.clientLeft;
            //var client_t = elem.clientTop;
            var scroll_w = elem.scrollWidth;
            var scroll_h = elem.scrollHeight;
            var scroll_l = elem.scrollLeft;
            var scroll_t = elem.scrollTop;
            var fac;

            if (sub_type.indexOf("HScroll") !== -1) {
                this.object_sub_type = sub_type;
                var hb_rect = {};

                hb_rect.left = b_rect.left;
                hb_rect.top = b_rect.top + client_h;
                hb_rect.right = hb_rect.left + client_w;
                hb_rect.bottom = b_rect.bottom;

                fac = 0.0;
                if (sub_type === "HScrollBtnL") {
                    return hb_rect.left + "," + hb_rect.top + "," + (hb_rect.left + scroll_button_size) + "," + hb_rect.bottom;
                }
                if (sub_type === "HScrollBtnR") {
                    return (hb_rect.right - scroll_button_size) + "," + hb_rect.top + "," + hb_rect.right + "," + hb_rect.bottom;
                }
                //var temp_rect = b_rect;
                hb_rect.left += scroll_button_size;
                hb_rect.right -= scroll_button_size;
                fac = scroll_h &gt; 0 ? (client_w - scroll_button_size) / scroll_w : 1;

                var hb_wdth = Math.round(fac * (client_w - scroll_button_size));
                if (sub_type === "HScrollAreaL") {
                    return hb_rect.left + "," + hb_rect.top + "," + (hb_rect.left + Math.round(scroll_l * fac)) + "," + hb_rect.bottom;
                }
                hb_rect.left += Math.round(scroll_l * fac);
                if (sub_type === "HScrollAreaR") {
                    return (hb_rect.left + hb_wdth) + "," + hb_rect.top + "," + hb_rect.right + "," + hb_rect.bottom;
                }
                if (sub_type === "HScrollBar") {
                    return hb_rect.left + "," + hb_rect.top + "," + (hb_rect.left + hb_wdth) + "," + hb_rect.bottom;
                }
            }
            if (sub_type.indexOf("VScroll") !== -1) {
                this.object_sub_type = sub_type;
                var vb_rect = {};
                vb_rect.left = b_rect.left + client_w;
                vb_rect.top = b_rect.top;
                vb_rect.right = b_rect.right;
                vb_rect.bottom = vb_rect.top + client_h;

                if (vb_rect.left == vb_rect.right) {
                    vb_rect.right = window.top.innerWidth;
                    vb_rect.bottom = window.top.innerHeight;
                }
                if (0 &gt; vb_rect.top) {
                    var top_diff = window.top.innerHeight - window.innerHeight;
                    vb_rect.top = top_diff;
                }

                fac = 0.0;
                if (sub_type === "VScrollBtnT") {
                    return vb_rect.left + "," + vb_rect.top + "," + vb_rect.right + "," + (vb_rect.top + scroll_button_size);
                }
                if (sub_type === "VScrollBtnB") {
                    return vb_rect.left + "," + (vb_rect.bottom - scroll_button_size) + "," + vb_rect.right + "," + vb_rect.bottom;
                }
                var temp_rect = b_rect;
                vb_rect.top += scroll_button_size;
                vb_rect.bottom -= scroll_button_size;
                fac = scroll_h &gt; 0 ? (client_h - scroll_button_size) / scroll_h : 1;
                var vb_hght = Math.round(fac * (client_h - scroll_button_size));

                if (sub_type === "VScrollAreaT") {
                    return vb_rect.left + "," + vb_rect.top + "," + vb_rect.right + "," + (vb_rect.top + Math.round(scroll_t * fac));
                }
                vb_rect.top += Math.round(scroll_t * fac);
                if (sub_type === "VScrollAreaB") {
                    return vb_rect.left + "," + (vb_rect.top + vb_hght) + "," + vb_rect.right + "," + vb_rect.bottom;
                }
                if (sub_type === "VScrollBar") {
                    return vb_rect.left + "," + vb_rect.top + "," + vb_rect.right + "," + (vb_rect.top + vb_hght);
                }
            }
        }
        return ret_val;
    }
};   // end HTMLElementRerecognition.prototype
// =============================================== Eep ================================================ //

DGO.BaseEep = function () { };

DGO.BaseEep.prototype = {

    ok: false,
    eep_path: null,
    eep_options: null,
    eep_atts: null,
    eep_coll: null,
    eep_parents: null,
    eep_siblingTags2: null,
    eep_elem_index: null,
    eep_elem_tag: null,
    eep_frame: null,
    eep_frame_name: null,
    eep_frame_src: null,
    client_x: null,
    client_y: null,
    options_: null,
    path_: null,
    coll_: null,
    eep_ori_: null,

    init: function (eep_string, resolve_options) {  // used to be Eep(eepString_, resolveOptions_)
        with (this) {
            this.options_ = resolve_options || {};
            this.eep_ori_ = eep_string;
            try {
                eval(eep_string);
            } catch (err) { exception_debugging(err); }
            this.path_ = this.eep_path;
            this.coll_ = typeof this.eep_coll === "object" &amp;&amp; this.eep_coll ?
                { collection: this.eep_coll.n, index: this.eep_coll.i, subindex: this.eep_coll.ii } :
                { collection: "", index: 0, subindex: -1 };
            this.ok = true;
        }
    },
    eep_resolve: function () {
        var obj = null;
        try {
            if (!this.eep_path || !this.eep_atts.tagName) {
                return window.document.body;
            }
            try {
                obj = EepUtils.Eep_resolveSimple(this.path_, this.eep_options);
                if (true === (this.qaElement_(obj))) return obj;
            } catch (err) { exception_debugging(err); }
            if (this.client_x !== "" &amp;&amp; this.client_y !== "") {
                obj = EepUtils.Eep_resolveClientPt_(this.client_x, this.client_y,
                    this.eep_atts, this.options_);
                if (obj &amp;&amp; (this.eep_atts.tagName === obj.tagName) &amp;&amp; (true === (this.qaElement_(obj)))) {
                    return obj;
                }
            }
        } catch (err) { exception_debugging(err); }
        try {
            if (this.eep_elem_tag) {
                obj = this.Eep_resolveTagIndex_();
                if (obj) return obj;
            }
        } catch (err) { exception_debugging(err); }
        try {
            if (this.eep_atts.id) {
                obj = EepUtils.Eep_resolveId_(this.eep_atts.id);
                if (obj) {
                    if (true === (this.qaInputElement_(obj))) return obj;
                    obj = EepUtils.Eep_resolveInputValue_(this.eep_atts.tagName, this.eep_atts.type,
                        this.eep_atts.name, this.eep_atts.value);
                    if (obj) return obj;
                }
            }
        } catch (err) { exception_debugging(err); }
        try {
            obj = EepUtils.Eep_resolveName_(this.eep_atts.name, this.eep_atts.tagName, true /*unique*/);
            if (obj) return obj;
        } catch (err) { exception_debugging(err); }
        try {
            if (this.options_.eep_use_text) {
                obj = EepUtils.Eep_resolveFirstText_(this.eep_atts.tagName, this.eep_atts.firstText,
                    this.options_, this.eep_atts.L || 0);
                if (true === (this.qaElement_(obj))) return obj;
            }
        } catch (err) { exception_debugging(err); }
        try {
            if (this.eep_atts.id) {
                obj = EepUtils.Eep_resolveId_(this.eep_atts.id);
                if (typeof obj === "object" &amp;&amp; obj) {
                    if (true === (this.qaElement_(obj))) return obj;
                }
            }
        } catch (err) { exception_debugging(err); }
    },
    Eep_resolveTagIndex_: function () {
        try {
            var obj = null;
            var tag_coll = window.document.getElementsByTagName(this.eep_elem_tag);
            var coll_length = tag_coll ? tag_coll.length : 0;
            if (coll_length) {
                var orig_index = Number(this.eep_elem_index);
                if (orig_index &lt; coll_length) {
                    obj = tag_coll.item(orig_index);
                    current_rerecognition_elem_index = orig_index;
                }
                if (obj &amp;&amp; (true === (this.qaElement_(obj)))) {
                    elem_index_within_frame = orig_index;
                    return obj;
                } else {
                    var iter = 1;
                    var keep_checking = true;

                    while (keep_checking) {
                        var trial_index = orig_index - iter;
                        if (trial_index &lt; coll_length &amp;&amp; trial_index &gt;= 0) {
                            obj = tag_coll.item(trial_index);
                            current_rerecognition_elem_index = trial_index;
                            if (true === (this.qaElement_(obj))) {
                                elem_index_within_frame = trial_index;
                                return obj;
                            }
                        }
                        trial_index = orig_index + iter;
                        if (trial_index &lt; coll_length) {
                            obj = tag_coll.item(trial_index);
                            current_rerecognition_elem_index = trial_index;
                            if (true === (this.qaElement_(obj))) {
                                elem_index_within_frame = trial_index;
                                return obj;
                            }
                        } else if (iter &gt; orig_index) {
                            keep_checking = false;
                        }
                        iter++;
                        if (iter &gt; 50) keep_checking = false;
                    }
                }
            }
        } catch (err) { exception_debugging(err); }
        return null;
    },
    qaPath_: function (obj) {
        try {
            if (!obj) return false;
            if (obj.tagName === "BODY" || obj.tagName === "FRAME") return true;

            var i = 0;
            var p = obj.parentNode;
            var parent, atts;
            while (p &amp;&amp; (p.tagName !== "BODY") &amp;&amp; (p.tagName !== "FRAME") &amp;&amp;
                typeof this.eep_parents[i] === "object") {
                parent = this.eep_parents[i];
                atts = parent.eep_atts || parent;
                if (!EepUtils.Eep_qaElement_(p, atts)) return "!=PATH(" + i + ")";

                p = p.parentNode;
                ++i;
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    qaElementAndPath_: function (obj) {
        var rc;
        return true !== (rc = this.qaElement_(obj)) ? rc : this.qaPath_(obj);
    },
    qaElement_: function (obj) {
        return EepUtils.Eep_qaElement_(obj, this.eep_atts, this.options_);
    },
    qaInputElement_: function (obj) {
        return EepUtils.Eep_qaInputElement_(obj, this.eep_atts);
    }
};  // end Eep.prototype

DGO.BaseEepUtils = function () { };

DGO.BaseEepUtils.prototype = {
    Eep_attrNames_: ["id", "name", "tagName", "type", "src"],
    Eep_getFirstTextNodeRE_: /[']?[^ \r\n\t][']?/,

    Eep_resolveClientPt_: function (client_x, client_y, eep_atts, options) {
        try {
            var obj = window.document.elementFromPoint(Number(client_x), Number(client_y));
            if (obj &amp;&amp; obj.tagName === "B") {
                obj = obj.parentElement;
            }
            if (obj &amp;&amp; (eep_atts.tagName === obj.tagName) &amp;&amp; (true === this.Eep_qaElement_(obj, eep_atts, options))) {
                return obj;
            }
        } catch (err) { exception_debugging(err); }
        return null;
    },
    Eep_resolveFirstText_: function (tagname, first_text, options, text_truncation) {
        if (!first_text) return null;

        if (text_truncation &gt; 0 &amp;&amp;
            first_text.length === text_truncation + 1 &amp;&amp;
            first_text.charAt(text_truncation) === "^") {
            first_text = first_text.substr(0, text_truncation);
        }
        var objs_hit = [];
        var objs = window.document.getElementsByTagName(tagname);
        var cmp1 = this.Eep_getRe4FirstText_(first_text, options);
        var i, obj, cmp2;
        if (cmp1) {
            for (i = 0; i &lt; objs.length; ++i) {
                obj = objs[i];
                cmp2 = this.Eep_getFirstTextNodeValue_(obj, text_truncation);

                if (cmp1 === this.Eep_getRe4FirstText_(cmp2, options)) {
                    objs_hit[objs_hit.length] = obj;
                }
            }
        } else {
            for (i = 0; i &lt; objs.length; ++i) {
                obj = objs[i];
                cmp2 = this.Eep_getFirstTextNodeValue_(obj, text_truncation);
                if (first_text === cmp2) objs_hit[objs_hit.length] = obj;
            }
        }
        return objs_hit.length === 1 ? objs_hit[0] : null;
    },
    Eep_getFirstTextNodeValue_: function (obj_, text_truncation_, flagDelimiter_) {   // SAP Web 3 version
        var node = this.Eep_getFirstTextNode_(obj_);
        if (!node || typeof node.nodeValue !== "string") return "";
        var ret_val = (new String(node.nodeValue)).alltrim();
        return text_truncation_ &gt; 0 &amp;&amp; ret_val.length &gt; text_truncation_
            ? ret_val.substr(0, text_truncation_) + (flagDelimiter_ ? "^" : "")
            : ret_val;
    },
    Eep_getElementInnerValue_: function (obj_, text_truncation_, flagDelimiter_) {
        var ret_val = "";
        try {
            var node = this.Eep_getFirstElementNode_(obj_);
            ret_val = node ? node.innerText : obj_.innerText;
            ret_val = ret_val.alltrim();
            return text_truncation_ &gt; 0 &amp;&amp; ret_val.length &gt; text_truncation_ ?
                ret_val.substr(0, text_truncation_) + (flagDelimiter_ ? "^" : "") : ret_val;

        } catch (e) { exception_debugging(e); }
        return "";
    },
    Eep_generateAttsString_: function (obj, options, text_truncation) {
        var str = "";
        var i, att, v, t;

        for (i = 0; i &lt; this.Eep_attrNames_.length; ++i) {
            att = this.Eep_attrNames_[i];
            v = obj[att];
            t = typeof v;
            if (v &amp;&amp; t === "string") {
                if (att === "id") {
                    var el;
                    var all_elems = window.document.getElementsByTagName("*");
                    //if (window.document.all &amp;&amp; (el = window.document.all[v]) &amp;&amp;
                    if (all_elems &amp;&amp; (el = all_elems[v]) &amp;&amp;
                        typeof el.length === "number" &amp;&amp; el.length !== 1) // mySAP, i.e., has lots of duplicate IDs
                    {
                        v = "";
                        t = "string";  // this makes the following ignore the ID
                    }
                }

                if (att === "name") {
                    if (window.document.getElementsByName(v).length !== 1) {
                        v = "";
                        t = "string";  // this makes the following ignore the ID
                    }
                }

                if (att === "src") {
                    v = DgoUtils.extract_img_src(v);
                }
            }

            if (v || (t !== "undefined" &amp;&amp; t !== "unknown" &amp;&amp; t !== "string")) {

                if (str !== "") str += ",";
                if (att === "type" &amp;&amp; v === "radio") str += ("value:" + obj.value.asJSstring() + ",");

                if (t === "number") {
                    str += (att + ":" + v);
                } else {
                    if (att === "tagName" &amp;&amp; v === "FRAME") v = "BODY";
                    str += (att + ':"' + v + '"');
                }
            }
        }

        if (obj.tagName &amp;&amp; eep_useInnerText &amp;&amp; eep_useInnerText.indexOf(":" + obj.tagName + ":") &gt;= 0 &amp;&amp; !DgoProfile.has_scroll(obj)) {
            t = this.Eep_getFirstTextNodeValue_(obj, text_truncation, true /*with delimiter*/);
            if (t || (t = this.Eep_getElementInnerValue_(obj, text_truncation, true))) {
                str += (text_truncation &gt; 0 ? ",L:" + text_truncation + ",firstText:" + t.asJSstring() : ",firstText:" + t.asJSstring());
            }
        }
        var objRect = obj.getBoundingClientRect();
        var objHt = parseInt(objRect.bottom) - parseInt(objRect.top);
        var objWt = parseInt(objRect.right) - parseInt(objRect.left);
        str += (",ht:" + objHt + ",wt:" + objWt);
        return str;
    },
    Eep_qaElementText_: function (obj, atts, options) {
        if (obj.tagName &amp;&amp; eep_useInnerText &amp;&amp; eep_useInnerText.indexOf(":" + obj.tagName + ":") &gt;= 0) {
            var newtext = this.Eep_getFirstTextNodeValue_(obj, 50, true /*with delimiter*/);
            if (!newtext) {
                newtext = this.Eep_getElementInnerValue_(obj, 50, true);
            }
        }
        if (atts.firstText) {
            var firstText = atts.firstText;
            var textTruncation = atts.L || 0;
            if (textTruncation &gt; 0 &amp;&amp; firstText.length === textTruncation + 1 &amp;&amp;
                firstText.charAt(textTruncation) === "^") {
                firstText = firstText.substr(0, textTruncation);
            }
            if (firstText.toUpperCase() !== newtext.toUpperCase()) {
                var start_pos = newtext.indexOf("(");
                if (-1 !== start_pos) {
                    if (0 === firstText.search(newtext.substring(0, start_pos))) return true;
                }
                return "!=TextTRIM";
            }
        } else if (newtext &amp;&amp; !DgoProfile.has_scroll(obj)) {
            return "!=TextTRIM";
        }
        return true;
    },
    Eep_generate: function (object) {
        try {
            var eep_textTruncation = 50;
            var obj = object.nodeType === 3 ? object.parentNode : object;
            var options = 1 + (eep_useInnerText ? 2 : 0);
            var eepString = "eep_path=\"" + this.Eep_getPathString(obj, 1) + "\";\r\n";
            eepString += "eep_options=" + options /*+ ';eep_version="6.1.1"*/ + ";\r\n";
            eepString += "eep_atts={" + this.Eep_generateAttsString_(obj, options, eep_textTruncation) + "};\r\n";
            eepString += "\r\n" + this.Eep_generateExtraInfo_(obj);
            return eepString;
        } catch (err) { exception_debugging(err); }
        return "error";
    },
    Eep_qaElement_: function (obj, atts, options) {
        if (!obj) return false;
        try {
            var match_width = true;
            var rc;
            var obj_Rect = obj.getBoundingClientRect();
            var objht = parseInt(obj_Rect.bottom) - parseInt(obj_Rect.top);
            var objwt = parseInt(obj_Rect.right) - parseInt(obj_Rect.left);
            if (atts.tagName) {
                if (!obj.tagName || (obj.tagName !== atts.tagName)) {
                    return "!=TAG";
                }
            }
            if (true !== (rc = this.Eep_qaInputElement_(obj, atts))) {
                return rc;
            }
            if (atts.src) {
                if (!obj.src || (DgoUtils.extract_img_src(obj.src) !== atts.src)) {
                    return "!=SRC";
                } else {
                    match_width = false;
                }
            }
            var newtext = this.Eep_getFirstTextNodeValue_(obj, 50, true /*with delimiter*/);
            if (!newtext) {
                newtext = this.Eep_getElementInnerValue_(obj, 50, true);
            }
            if (!options || options &amp;&amp; options.eep_use_text === "true" &amp;&amp; newtext) {
                if (true !== (rc = this.Eep_qaElementText_(obj, atts, options))) {
                    return rc;
                } else {
                    match_width = false;
                }
            }
            if (atts.id) {
                if ((obj.id &amp;&amp; obj.id !== atts.id &amp;&amp; !this.partial_id_comp_(atts.id, obj.id)) || !obj.id) {
                    return "!=ID";
                } else {
                    match_width = false;
                }
            } else if (obj.id) {
                var el;
                var doc = DgoProfile.get_doc_from_elem(obj);
                var all_elems = doc.getElementsByTagName("*");
                //if (doc &amp;&amp; doc.all &amp;&amp; (el = doc.all[obj.id]) &amp;&amp; typeof el.length === "number" &amp;&amp; el.length &gt; 1)
                if (all_elems &amp;&amp; (el = all_elems[obj.id]) &amp;&amp; (typeof el.length === "number") &amp;&amp; (el.length &gt;= 1)) {
                    // mySAP, i.e., has lots of duplicate IDs
                } else {
                    return "!=ID";
                }
            }
            if (atts.ht &amp;&amp; atts.wt &amp;&amp; match_width) {
                if (!objht || !objwt ||
                    (match_width &amp;&amp; (objwt &lt;= (atts.wt - 2) || objwt &gt;= (atts.wt + 2))) ||
                    (objht &lt;= (atts.ht - 2) || objht &gt;= (atts.ht + 2))) {
                    return "!=DIMENSIONS";
                }
            }
        } catch (err) {
            exception_debugging(err);
            return false;
        }
        return true;
    },
    partial_id_comp_: function (rec_id, rerec_id) {
        if (!rec_id || !rerec_id) return false;
        try {
            var sub_str_id_1 = "";
            var sub_str_id_2 = "";
            if (ignore_ids) return true;
            if (ignore_dynamic_ids === 1) {
                for (var i = 0; i &lt; rec_id.length; i++) {
                    if ((i &lt; rerec_id.length) &amp;&amp; !isNaN(rerec_id.charAt(i))) {
                        sub_str_id_2 = rerec_id.substring(0, i);
                    }
                    if (!isNaN(rec_id.charAt(i))) {
                        sub_str_id_1 = rec_id.substring(0, i);
                        break;
                    }
                }
            }
            if (sub_str_id_1 === sub_str_id_2) {
                return true;
            }
        } catch (err) { exception_debugging(err); }
        return false;
    },
    Eep_getRe4FirstText_: function (first_text, options) {
        if (!options || !options.eep_first_text_re || typeof options.eep_first_text_re.exec !== "function") return null;

        var rc = options.eep_first_text_re.exec(first_text);
        if (!rc || rc.length &lt;= 1) return "";

        var ret_val = "";
        for (var i = 1; i &lt; rc.length; ++i) {
            ret_val += rc[i];
        }
        return ret_val;
    },
    Eep_getElementRef: function (obj) {
        var coll = this.Eep_generateCollectionObject_(obj) || { n: "", i: "0", ii: "-1" };
        return new ElementRef(this.Eep_getPathString(obj), /* Producer compatible */ coll.n, coll.i, coll.ii, this.Eep_generate(obj));
    },
    Eep_resolveId_: function (id) {
        if (!id) return null;
        try {
            //if (window.document.all &amp;&amp; window.document.all[id] &amp;&amp;
            //    typeof window.document.all[id].length === "number" &amp;&amp;
            //    window.document.all[id].length !== 1) {
            //    return window.document.all[id].length;
            var all_elems = window.document.getElementsByTagName("*");
            if (all_elems &amp;&amp; all_elems[id] &amp;&amp; typeof all_elems[id].length === "number" &amp;&amp;
                window.all_elems[id].length !== 1) {
                return all_elems[id].length;
            }
            return window.document.getElementById(id);
        } catch (err) { exception_debugging(err); }
        return null;
    },
    Eep_resolveName_: function (name, tagname /*NC4 only*/, flagUnique) {
        if (!name) return null;
        try {
            var objs = window.document.getElementsByName(name);
            return objs.length === 0 || flagUnique &amp;&amp; objs.length &gt; 1 ? null : objs[0];
        } catch (err) { exception_debugging(err); }
        return null;
    },
    Eep_resolveInputValue_: function (tagname, type, name, value) {
        if (tagname !== "INPUT" &amp;&amp; type !== "radio") return null;
        try {
            var objs = window.document.getElementsByName(name);
            if (objs.length === 0) return null;

            var obj;
            for (var i = 0; i &lt; objs.length; ++i) {
                obj = objs[i];
                if (obj.type === "radio" &amp;&amp; obj.value === value) return obj;
            }
        } catch (err) { exception_debugging(err); }
        return null;
    },
    Eep_resolveSimple: function (path, options, base_el) {
        var el;
        try {
            el = window.document.body;
            if (path === "") return el;
            el = base_el || el;
            var opt = options || 0;
            var path_bits = path.split(":");
            var i, idx, children, ii, child, type;
            for (i = 0; el &amp;&amp; i &lt; path_bits.length; ++i) {
                idx = path_bits[i] - 0;
                children = opt &amp; 1 ? el.childNodes : el.children || el.childNodes;
                el = null;
                for (ii = 0; el === null &amp;&amp; ii &lt; children.length; ++ii) {
                    child = children[ii];
                    type = opt &amp; 1 &amp;&amp; child.tagName &amp;&amp; child.tagName === "!" ? 8 : child.nodeType;
                    if (type === 1 &amp;&amp; idx === 0) {
                        el = child;
                    } else {
                        if (opt &amp; 1) {
                            if (type === 1)--idx;
                        } else {
                            if (type !== 3)--idx;
                        }
                    }
                }
            }
        } catch (err) { exception_debugging(err); }
        return el;
    },
    Eep_resolveByDirectPath: function (path) {
        var el;
        try {
            el = window.document.body;
            if (!path) {
                return el;
            }
            var split_path = path.split(":");
            var i, idx;
            for (i = 0; el &amp;&amp; i &lt; split_path.length; ++i) {
                idx = split_path[i] - 0;
                if (idx &lt; el.children.length) el = el.children.item(idx);
            }
        } catch (err) { exception_debugging(err); }
        return el;
    },
    Eep_generateExtraInfo_: function (obj) {
        if (!obj) return "";

        var str = "";
        var tagname = obj.tagName;
        var doc = DgoProfile.get_doc_from_elem(obj);
        if (doc) {
            var tag_coll = doc.getElementsByTagName(tagname);  //test for multiple frame case
            // debugger;
            if (tag_coll) {
                var tag_coll_length = tag_coll.length;
                for (var i = 0; i &lt; tag_coll_length; i++) {
                    var child = tag_coll.item(i);
                    if (obj === child) {
                        str = "eep_elem_index=\"" + i + "\";eep_elem_tag=\"" + tagname + "\";";
                        break;
                    }
                }
            }
        }
        str += "eep_frame_name=\"" + window.name + "\";eep_frame_src=\"" + "" + "\";";
        return str;
    },
    Eep_getPathString: function (obj, opts) {
        var options = opts || 0;
        if (options &amp; 4 /*top-down*/) return this.Eep_getPathString2_(obj, options);

        var er = "";    // datango simple element reference
        var x = obj;   // element
        var /* i, */ ii, p, children, kk, child;

        if (x.nodeType === 3 /*text*/ ||
            (x.tagName &amp;&amp; x.tagName !== "APPLET" &amp;&amp; x.tagName !== "EMBED" &amp;&amp; (x.tagName !== x.tagName.toUpperCase() /*XUL*/ || x.toString().indexOf("XUL") &gt;= 0))) {
            x = x.parentNode;
        }

        while (x &amp;&amp; (p = x.parentNode) !== null &amp;&amp; typeof x.tagName === "string" &amp;&amp; x.tagName !== "BODY" &amp;&amp; x.tagName !== "FRAMESET") {
            children = options &amp; 1 ?
                p.childNodes /*W3C Std*/ :
                p.children /*IE*/ || p.childNodes /*W3C Std*/;
            kk = -1;

            for (ii = 0; child !== x &amp;&amp; ii &lt; children.length; ++ii) {
                child = children[ii];

                if (options &amp; 1) {
                    if (child.nodeType === 1 &amp;&amp; child.tagName !== "!")++kk;
                } else {  // Producer compatible
                    if (child.nodeType !== 3)++kk; // DOM Text Node
                }
            }

            if (child !== x) return "";

            if (er) er = ":" + er;
            er = kk + er;
            x = p;
        }
        return er;
    },
    Eep_getFirstTextNode_: function (obj) {
        var children = obj.childNodes || [];  // DOM child collection with text nodes
        var node;

        for (var i = 0; i &lt; children.length; ++i) {
            node = children[i];
            if (node.nodeType &amp;&amp; node.nodeType === 3 &amp;&amp; node.nodeValue.search(this.Eep_getFirstTextNodeRE_) &gt;= 0) {
                return node;
            }
        }
        return null;
    },
    Eep_getFirstElementNode_: function (obj) {
        var children = obj.childNodes || [];  // DOM child collection with text nodes
        var node;

        for (var i = 0; i &lt; children.length; ++i) {
            node = children[i];
            if (node.nodeType &amp;&amp; DgoUtils.is_valid_str(node.innerText)) {
                return node;
            }
        }
        return null;
    },
    Eep_generateParentsString_: function (obj, options, tags4text) {
        return "";  // Now we don't require parent info as ReRecognition doesn't have top down approach
        //if (!obj || obj.tagName === "BODY" || obj.tagName === "FRAME" || !obj.parentNode) return "";

        //var str = "";
        //var p = obj.parentNode;

        //while (p &amp;&amp; p.tagName !== "BODY" &amp;&amp; p.tagName !== "FRAME") {
        //    str += (",\r\n{" + Eep_generateAttsString_(p, frame_, options, "", 0) + "}");
        //    p = p.parentNode;
        //}
        //return str.substr(3);
    },
    Eep_generateSiblingsString_: function (obj) {
        if (!obj || !obj.parentNode || obj.tagName === "BODY" || obj.tagName === "FRAME") {
            return "";
        }
        var str = "";
        var children = obj.parentNode.childNodes;
        var child;
        for (var i = 0; i &lt; children.length; ++i) {
            child = children[i];
            if (child.nodeType === 1 &amp;&amp; child.tagName !== "!") {  // exclude comments
                if (child.tagName.charAt(0) !== "/") {
                    str += child === obj ?
                        ":_" + children[i].tagName + "_" :
                        ":" + children[i].tagName;
                }
            }
        }
        return str.substr(1);
    },
    Eep_generateCollectionString_: function (x) {
        var ret_val = this.Eep_generateCollectionObject_(x);
        return ret_val ?
            'n:"' + ret_val.n + '",i:' + ret_val.i + ',ii:' + ret_val.ii :
            'n:"",i:0,ii:-1';
    },
    Eep_generateCollectionObject_: function (x) {
        if (!x) return null;
        switch (x.tagName) {
            case "INPUT":
            case "TEXTAREA":
            case "SELECT":
            case "OPTION":
            case "BUTTON":
            case "FORM":
                return this.Eep_getElementCollection_("forms", x);
            case "IMG":
                return this.Eep_getElementCollection_("images", x);
            case "A":
                return this.Eep_getElementCollection_((x.name ? "anchors" : "links"), x);
            case "DIV":
                return this.Eep_getElementCollection_("layers", x);
            case "APPLET":
                return this.Eep_getElementCollection_("applets", x);
            case "EMBED":
                return this.Eep_getElementCollection_("embeds", x);
            default:
                return null;
        }
    },
    Eep_getElementCollection_: function (collName, x) {
        var coll = window ? window.document[collName] : null;

        if (typeof coll === "object" &amp;&amp; coll &amp;&amp; typeof coll.length === "number") {
            var cmp;
            var ii;
            for (var i = 0; i &lt; coll.length; ++i) {
                cmp = coll[i];

                if (cmp === x) {
                    return { n: collName, i: "" + i, ii: "-1" };
                } else if (typeof cmp === "object" &amp;&amp; typeof cmp.length === "number") {
                    for (ii = 0; ii &lt; cmp.length; ++ii) {
                        if (cmp[ii] === x) {
                            return { n: collName, i: "" + i, ii: "" + ii };
                        }
                    }
                }
            }
        }
        return { n: "", i: "0", ii: "-1" };
    },
    Eep_getPathString2_: function (obj, opts) {
        var options = opts || 0;
        var er = "";
        var x = obj;
        var i, ii, p, children, kk, child;

        if (x.nodeType === 3 /*text*/ ||
            (x.tagName &amp;&amp; x.tagName !== "APPLET" &amp;&amp; x.tagName !== "EMBED" &amp;&amp; (x.tagName !== x.tagName.toUpperCase() /*XUL*/ || x.toString().indexOf("XUL") &gt;= 0))) {
            x = x.parentNode;
        }

        var body;
        if (x &amp;&amp; x.ownerDocument) {
            body = x.ownerDocument.body;
        } else {
            p = x;
            while (p &amp;&amp; p.tagName !== "BODY") {
                p = p.parentNode;
            }
            if (!p) return "EPerr:above_body";
            body = p;
        }
        var ret_val = this.Eep_getPathString2_rek_(body, x, opts);
        return ret_val === false ? "EPerr:not_found" : ret_val;
    },
    Eep_getPathString2_rek_: function (parent, obj, options) {
        if (parent === obj) return "";
        var children = options &amp; 1 ?
            parent.childNodes /*W3C Std*/ :
            parent.children /*IE*/ || parent.childNodes /*W3C Std*/;
        var kk = -1;
        var i, child, rc;
        for (i = 0; i &lt; children.length; ++i) {
            child = children[i];
            if (options &amp; 1) {
                if (child.nodeType === 1 &amp;&amp; child.tagName !== "!")++kk;
            } else {
                if (child.nodeType !== 3)++kk;
            }

            if (child.nodeType === 1 &amp;&amp; child.tagName !== "!" &amp;&amp;
                false !== (rc = this.Eep_getPathString2_rek_(child, obj, options))) {
                return rc ? kk + ":" + rc : "" + kk;
            }
        }
        return false;
    },
    Eep_getNodeHtml: function (obj) {
        if (typeof DHtml_getNodeHtml === "function") return DHtml_getNodeHtml(obj);
        if (!obj) return "(null)";
        if (typeof obj !== "object") return "\"" + obj + "\" [" + typeof obj + "]";
        if (obj.tagName) return obj.tagName;
        if (obj.nodeType) return "(nodetype=" + obj.nodeType + ")";
        return "(?)";
    },
    Eep_qaInputElement_: function (obj, atts) {
        if (!obj) return false;
        try {
            if (atts.type) {
                if (!obj.type || (obj.type &amp;&amp; obj.type !== atts.type)) {
                    return "!=TYPE";
                }
            } else if (obj.type) {
                return "!=TYPE";
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    }
};
// =============================================== Utils ================================================ //
DGO.Utils = function () { };

DGO.Utils.prototype = {
    use_old_version: false,
    extract_src_from_string: function (frm_src, startToken, endToken) {
        try {
            var end_pos = frm_src.indexOf(endToken);
            if (-1 === end_pos) end_pos = frm_src.length - 1;
            var start_pos = frm_src.lastIndexOf(startToken, end_pos);
            start_pos = -1 === start_pos ? 0 : start_pos + 1;
            var res = frm_src.substring(start_pos, end_pos);
            return res;
        } catch (err) { exception_debugging(err); }
        return frm_src;
    },
    extract_img_src: function (frm_src) {
        try {
            var lastIndexOfToken = "/";
            var remove_strings = ["_hover"];
            if (frm_src) {
                var end_pos = frm_src.length;
                var start_pos = frm_src.lastIndexOf(lastIndexOfToken);
                start_pos = -1 === start_pos ? 0 : start_pos + 1;
                var res = frm_src.substring(start_pos, end_pos);
                for (var i = 0; i &lt; remove_strings.length; i++) {
                    res = res.replace(remove_strings[i], "");
                }
                return res;
            }
        } catch (err) { exception_debugging(err); }
        return frm_src;
    },
    is_valid_str: function (str) {
        return typeof str !== "undefined" &amp;&amp; str !== null &amp;&amp; str !== "" &amp;&amp; str !== "Untitled";
    },
    trim: function (inputStr) {
        // This function is used for trim leading and trailing space in a string.
        // It will also remove new line and tabs present in a string.
        return this.is_valid_str(inputStr) ? inputStr.replace(/^\s+|\s+$/g, "").replace(/[\r\n\x0B\x0C\u0085\u2028\u2029]+/g, " ") : "";
    },
    get_tree_item_from_id: function (obj_id) {
        try {
            var obj_id_node = window.document.getElementById(obj_id);
            if (typeof obj_id_node === "object" &amp;&amp; obj_id_node !== null) {
                var elmcoll = window.document.getElementsByName(obj_id);
                if (elmcoll.length &lt; 2) return obj_id_node;
            }
        } catch (err) { exception_debugging(err); }
        return "";
    },
    get_frame_with_name: function (frame_name) {
        try {
            if (window.document.document.title === frame_name) return frame_name;
        } catch (err) { exception_debugging(err); }
        return "";
    },
    to_hex: function (n) {
        try {
            n = parseInt(n, 10);
            if (isNaN(n)) return "00";
            n = Math.max(0, Math.min(n, 255));
            return "0123456789ABCDEF".charAt((n - n % 16) / 16) + "0123456789ABCDEF".charAt(n % 16);
        } catch (err) { exception_debugging(err); }
        return "00";
    },
    rgb_to_hex: function (str) {
        try {
            var font_color = "#";
            var start = str.indexOf("(");
            var end = str.indexOf(",");
            var i = 0;
            while (i &lt; 3) {
                var r = str.substring(start + 1, end);
                font_color = font_color + this.to_hex(r);
                start = end;
                str = str.replace(",", ";");
                end = str.indexOf(",");
                if (end === -1) end = str.indexOf(")");
                i++;
            }
            return font_color;
        } catch (err) { exception_debugging(err); }
        return "";
    },
    is_in_array: function (element, array) {
        if (!this.use_old_version) {
            try {
                return array.indexOf(element) &gt;= 0;
            } catch (err) {
                this.use_old_version = true;
            }
        }
        for (var i = 0; i &lt; array.length; i++) {
            if (array[i] === element) return true;
        }
        return false;
    },
    get_ie_version: function () {
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf('MSIE ');
        if (msie &gt; 0) {
            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
        }

        var trident = ua.indexOf('Trident/');
        if (trident &gt; 0) {
            var rv = ua.indexOf('rv:');
            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
        }

        var edge = ua.indexOf('Edge/');
        if (edge &gt; 0) {
            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
        }

        return 11;
    },
    get_element_by_classname: function (node, classname) {
        try {
            if (node) {
                if (node.getElementsByClassName) {
                    return node.getElementsByClassName(classname);
                } else {
                    var coll = [];
                    var all = node.getElementsByTagName("*");
                    for (var i = 0; i &lt; all.length; ++i) {
                        var elem = all[i];
                        if (elem &amp;&amp; elem.className &amp;&amp; this.element_has_classname(elem, classname)) {
                            coll.push(elem);
                        }
                    }
                    return coll;
                }
            }
        } catch (err) { exception_debugging(err); }
        return [];
    },
    element_has_classname: function (element, classlist) {
        if (element) {
            var classes = classlist.split(" ");
            var match = classes.length &gt; 0;
            if (element.classList) {
                for (var i = 0; i &lt; classes.length; ++i) {
                    match = match &amp;&amp; element.classList.contains(classes[i]);
                    if (!match) return false;
                }
            } else {
                var elem_classlist = " " + element.className + " ";
                for (var i = 0; i &lt; classes.length; ++i) {
                    match = match &amp;&amp; elem_classlist.indexOf(" " + classes[i] + " ") &gt;= 0;
                    if (!match) return false;
                }
            }
            return match;
        }
        return false;
    },
    get_zindex: function (element) {
        try {
            while (element) {
                var cstyle = window.getComputedStyle(element);
                if (cstyle.getPropertyValue("position") !== "static") {
                    var z = cstyle.getPropertyValue("z-index");
                    if (!isNaN(z)) return parseInt(z);
                }
                element = element.parentElement;
            }
        } catch (err) { exception_debugging(err); }
        return 0;
    },
    get_role: function (element) {
        return (element &amp;&amp; (element.getAttribute("role") || element.getAttribute("type")));
    },
    has_popup: function (element) {
        return (element &amp;&amp; element.getAttribute("aria-haspopup"));
    },
    partial_search: function (classname, array) {
        if (!classname || !array) return false;
        for (var i = 0; i &lt; array.length; i++) {
            if (classname &amp;&amp; classname.search(array[i]) !== -1) return true;
        }
        return false;
    },
    search_by_className: function (coll, classname) {
        if (!coll || !classname) return null;
        for (var i = 0; i &lt; coll.length; i++) {
            var elem = coll[i];
            if (elem.className.search(classname) !== -1) return elem;
        }
        return null;
    },
    get_elements_by_tagname_and_attr: function (element, tag_name, attr_name, attr_vals) {
        if (!element) return null;
        var elems = [];
        var tag_coll = element.getElementsByTagName(tag_name);
        for (var i = 0; i &lt; tag_coll.length; i++) {
            var elem = tag_coll[i];
            if (this.is_in_array(elem.getAttribute(attr_name), attr_vals)) {
                elems.push(elem);
            }
        }
        return elems;
    },
    search_by_class: function (elem, class_coll) {
        for (var i = 0; i &lt; class_coll.length; i++) {
            var act_class_coll = DgoUtils.get_element_by_classname(elem, class_coll[i]);
            if (act_class_coll &amp;&amp; act_class_coll.length) return true;
        }

        return false;
    },
    get_topmost_element: function (elements) {
        if (!elements || elements.length &lt;= 0) return null;

        var max_i = -1;
        var max_z = -10000;
        for (var i = 0; i &lt; elements.length; ++i) {
            var element = elements[i];
            if (this.is_visible_displayed(element)) {
                var z = DgoUtils.get_zindex(element);
                if (z &gt; max_z) {
                    max_i = i;
                    max_z = z;
                }
            }
        }
        return max_i === -1 ? null : elements[max_i];
    },
    is_visible_displayed: function (element) {
        if (!element) return true;
        var cstyle = window.getComputedStyle(element);
        if (cstyle &amp;&amp; (cstyle.display === "none" || cstyle.visibility === "hidden")) return false;
        return this.is_visible_displayed(element.parentElement);
    },
    find_parent_by_tagname_and_attr: function (element, tag_name, attr_name, attr_vals) {
        if (!element) return null;
        var parent = element.parentNode;
        for (var i = 0; i &lt; 10; i++) {
            if (!parent) break;
            if (parent.tagName === tag_name &amp;&amp; this.is_in_array(parent.getAttribute(attr_name), attr_vals)) {
                return parent;
            }
            parent = parent.parentNode;
        }
        return null;
    },
    get_title: function () {
        return document.title;
    },
    get_url: function () {
        return window.location.href;
    }
};
// ================================== EXAMPLE CODE FOR LIBRARY AND PROFILE EXTENSIONS ================================== //
//// ----- common script
//function extendObj(dst, src) {
//    for (var i in src) {
//        if (src.hasOwnProperty(i)) dst[i] = src[i];
//    }
//}

//var DGO = window.DGO || {};

//DGO.Base = function() {}

//DGO.Base.prototype = {
//    check_handler: function() {
//        return "base check";
//    }
//}
////----- library script
//DGO.Extended = function() {
//    DGO.Base.call(this);
//}

//DGO.Extended.prototype = new DGO.Base();

//extendObj(DGO.Extended.prototype, {
//    check_handler: function() {
//        return "ext check";
//    }
//});
//var DgoProfile = new DGO.Extended();

////----- profile script
//DGO.ExtendedProfile = function() {
//    DGO.Extended.call(this);
//}

//DGO.ExtendedProfile.prototype = new DGO.Extended();

//extendObj(DGO.ExtendedProfile.prototype, {
//    check_handler: function() {
//        return "ext profile check";
//    }
//});
//DgoProfile = new DGO.ExtendedProfile();

//console.log("Hi!");
//console.log("base: " + DGO.Base.prototype.check_handler());
//console.log("ext: " + DGO.Extended.prototype.check_handler());
//console.log("ext profile: " + DGO.ExtendedProfile.prototype.check_handler());
//console.log("profile: " + DgoProfile.check_handler());

//var DGO = window.DGO || {};
DGO.Effect = function () { };

DGO.Effect.prototype = {
    overlay: {
        element: null,
        id: "help4-recording-path-quality-highlight",
        active: false,
        //capture_rect_css: "position: absolute; z-index: 1000001; pointer-events: none; transform: translate(-3px, -3px); border: solid 3px #ffc000; background-color: rgba(255,192,0,0.15);",
        //safe_css: "border-color: #408600; background-color: rgba(64,134,0,0.15);",
        timestamp: 0
    },

    activate: function () {
        if (this.overlay.active === true) return;
        //console.log("DgoEffect activated");
        this.overlay.active = true;
        this.overlay.timestamp = Date.now();
        if (document.addEventListener) {
            document.addEventListener("mouseover", this.mouse_effect_handler);
        } else if (document.attachEvent) {
            document.attachEvent("mouseover", this.mouse_effect_handler);
        }
    },
    deactivate: function () {
        if (this.overlay.active === false) return;
        //console.log("DgoEffect deactivated");
        this.overlay.active = false;
        this.get_overlay().style.visibility = "hidden";
        if (document.removeEventListener) {
            document.removeEventListener("mouseover", this.mouse_effect_handler);
        } else if (document.detachEvent) {
            document.detachEvent("mouseover", this.mouse_effect_handler);
        }
    },
    get_overlay: function () {
        return this.overlay.element ? this.overlay.element : this.create_overlay();
    },
    create_overlay: function () {
        var overlay_element = window.document.getElementById(this.overlay.id);
        if (overlay_element) {
            this.overlay.element = overlay_element;
            return overlay_element;
        }
        //console.log("creating new overlay");
        overlay_element = window.document.createElement("div");
        overlay_element.id = this.overlay.id;
        this.overlay.element = window.document.body ? window.document.body.appendChild(overlay_element) : null;
        return this.overlay.element;
    },
    mouse_effect_handler: function (e) {
        try {
            e = e || event;
            if (!e || !e.target) return;

            if (e.type === "mouseover") {
                //console.log("mouseover effect");
                if (DgoEffect.overlay.active === false || typeof generate_xray_path !== "function") return;  // needs xRay.js
                var p = generate_xray_path(e.target, Help4R.selector.Shell);  // xRay.js
                var target_pos = (p &amp;&amp; p.elem) ? p.elem.getBoundingClientRect() : e.target.getBoundingClientRect();

                var overlay_style = DgoEffect.get_overlay().style;
                overlay_style.cssText = _HELP4_CONTROL_CAPTURERECT_CSS + ((p &amp;&amp; p.safe === 1.0) ? _HELP4_SAFE_CSS : "");
                overlay_style.visibility = "";
                overlay_style.left = target_pos.left.toString() + "px";
                overlay_style.top = target_pos.top.toString() + "px";
                overlay_style.width = (target_pos.right - target_pos.left).toString() + "px";
                overlay_style.height = (target_pos.bottom - target_pos.top).toString() + "px";

                //console.log("over " + e.target.tagName + ":" + e.target.className + " pos: " + target_pos.left + "x" + target_pos.top + ((p &amp;&amp; p.elem) ? " (selector element)" : " (event target)"));
                //console.log("effect active: " + DgoEffect.overlay.active + " timestamp: " + DgoEffect.overlay.timestamp);
                //console.log("rule: " + p.rule.toString());
                //console.log("selector: Help4R.selector.Shell"));

                // prevent other mouseover effects
                e.cancelBubble = true;
            }
        } catch (err) { exception_debugging(err); }
    }
};
//var DgoEffect = DgoEffect || new DGO.Effect();

// to active the mouse over effect call:
//DgoEffect.activate();
// to deactivate call:
//DgoEffect.deactivate();


// include file: ../HTMLBasic/script.js

// declared in final profile
//var EepUtils = new DGO.BasicEepUtils();
//var DgoUtils = new DGO.Utils();

// HTML Basic
DGO.HTMLBasic = function () {
    DGO.Base.call(this);
};

DGO.HTMLBasic.prototype = new DGO.Base();

extendObj(DGO.HTMLBasic.prototype, {
    element_rect: null,
    elem_xtype: function (e) {
        var type = this.elem_xtype_from_role(e);
        if (!type) {
            type = this.elem_xtype_from_class(e);
        }
        return type;
    },

    elem_xtype_from_role: function (e) {
        var type = DgoUtils.get_role(e);
        if (type &amp;&amp; DgoUtils.is_in_array(type, DgoProfile.get_valid_roles())) {
            type = this.correct_type(type, e);
            if (type &amp;&amp; this.check_handler(type)) {
                type = this.convert_to_compat(type);
                return type;
            }
        }
        return "";
    },

    elem_xtype_from_class: function (e) {
        return DGO.Base.prototype.elem_xtype.call(this, e);
    },

    correct_type: function(type, e) {
        if (type === "button") {
            var parent = e.parentNode;
            var elmpopup = DgoUtils.has_popup(e);
            var parentpopup = DgoUtils.has_popup(parent);
            if (elmpopup || parentpopup) {
                type = "dropdown";
            }
        } else if (type === "radio" || type === "checkbox") {
            var width = parseInt(this.element_rect.right) - parseInt(this.element_rect.left);
            var height = parseInt(this.element_rect.bottom) - parseInt(this.element_rect.top);
            if (width &gt; (height * 1.5)) {
                type = "labeltext";
            }
        }
        return type;
    },
    get_valid_roles: function () {
        return [
            "link",
            "button",
            "text",
            "labeltext",
            "checkbox",
            "submit",
            "tab",
            "rowheader",
            "option",
            "radio",
            "combobox",
            "menuitem",
            "search"
        ];
    },
    get_role_depth: function () {
        return 3;
    },

    check_handler: function (type) {
        var valid_htmlbasic_tags = [
            "A",
            "BUTTON",
            "DIV",
            "HScrollBtnR",
            "HScrollBtnL",
            "HScrollBar",
            "HScrollAreaR",
            "HScrollAreaL",
            "INPUTpassword",
            "INPUTsubmit",
            "INPUTbutton",
            "INPUTcheckbox",
            "INPUTcheckboxOn",
            "INPUTcheckboxOff",
            "INPUTfile",
            "INPUTradio",
            "INPUTsearch",
            "INPUTtext",
            "dropdown",
            "IMGA:",
            "IMGSPAN:",
            "SELECT",
            "SPAN",
            "TEXTAREA",
            "VScrollAreaB",
            "VScrollAreaT",
            "VScrollBar",
            "VScrollBtnB",
            "VScrollBtnT"];
        return DgoUtils.is_in_array(type, valid_htmlbasic_tags) ||
            DGO.Base.prototype.check_handler.call(this, type);
    },
    get_xray_screen_id: function () {
        try {
            return _getScreenId();
        } catch (err) { exception_debugging(err); }
        return "";
    },
    convert_to_compat: function (type) {
        var new_type = type;

        switch (type) {
            case "link":
            case "labeltext":
            case "option":
                new_type = "Hrefarea";
                break;
            case "dropdown":
                new_type = "dropdown";
                break;
            case "submit":
            case "button":
                new_type = "Button";
                break;
            case "text":
            case "search":
                new_type = "Edit";
                break;
            case "tab":
                new_type = "Pagetab";
                break;
            case "checkbox":
                new_type = "Checkbox";
                break;
            case "radio":
                new_type = "Radio Button";
                break;
            case "rowheader":
                new_type = "Checkbox_1";
                break;
        }
        if (new_type !== type) return new_type;
        return new_type !== type ? new_type : DGO.Base.prototype.convert_to_compat.call(this, type);
    },
    empty: function () {
        return "";      // key can be removed after DPS-44325
    }
});
// do not use this library as full profile
var DgoProfile = new DGO.HTMLBasic(); // use DGO.HTMLBasic in final profile
var DgoEep = new DGO.BaseEep();
var EepUtils = new DGO.BaseEepUtils();
var DgoUtils = new DGO.Utils();
var DgoProcessing = new DGO.BaseProcessing();
// ---------------------------------------------------
DGO.HtmlBasicHTMLElementRecognition = function () {
    DGO.BaseHTMLElementRecognition.call(this);
};
DGO.HtmlBasicHTMLElementRecognition.prototype = new DGO.BaseHTMLElementRecognition();

extendObj(DGO.HtmlBasicHTMLElementRecognition.prototype, {
    get_element_from_point: function (point_x, point_y) {
        try {
            var get_elem = DGO.BaseHTMLElementRecognition.prototype.get_element_from_point.call(this, point_x, point_y);
            var elem = this.get_role_elem(this.element);
            var ret = DgoUtils.get_role(elem);
            if (ret &amp;&amp; DgoUtils.is_in_array(ret, DgoProfile.get_valid_roles())) {
                this.element = elem;
                this.has_role = true;
                return true;
            }
            return get_elem;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    get_bc_rect: function () {
        this.element_rect = this.element.getBoundingClientRect();
        var role = DgoUtils.get_role(this.element);            
        if (role === "checkbox" || role === "radio") {
            var elm_rect = this.element_rect;
            var height = parseInt(elm_rect.bottom) - parseInt(elm_rect.top);
            var rect_right = DgoProfile.offset_rect(elm_rect, 0, 0);
            rect_right.right = parseInt(rect_right.left) + parseInt(height - 5);
            if (this.pt_in_rect(this.client_x, this.client_y, rect_right)) {
                this.element_rect = DgoProfile.offset_rect(rect_right, this.frame_offset_x, this.frame_offset_y);
                return true;
            }
        }
        return this.correct_bc_rect() || DGO.BaseHTMLElementRecognition.prototype.get_bc_rect.call(this);
    },
    correct_bc_rect: function () {
        return false;
    },
    pt_in_rect: function(x, y, rect) {
        return (x &gt;= parseInt(rect.left) &amp;&amp;
                x &lt;= parseInt(rect.right) &amp;&amp;
                y &gt;= parseInt(rect.top) &amp;&amp;
                y &lt;= parseInt(rect.bottom));
    },
    get_role_elem: function(elem) {
        for (var iter = 0; iter &lt; DgoProfile.get_role_depth(); iter++) {
            var role = DgoUtils.get_role(elem);
            if (role &amp;&amp; DgoUtils.is_in_array(role, DgoProfile.get_valid_roles())) {
                break;
            }
            if(elem !== null){
                elem = elem.parentNode;
            }
        }
        return elem;
    }
        
});
var HTMLElementRecognition = new DGO.HtmlBasicHTMLElementRecognition();


DGO.XRayHTMLElementRecognition = function () {
    DGO.BaseHTMLElementRecognition.call(this);
};
DGO.XRayHTMLElementRecognition.prototype = new DGO.BaseHTMLElementRecognition();
extendObj(DGO.XRayHTMLElementRecognition.prototype, {
    xray_path: "",
    path_safe: 1,
    get_element_from_point: function (point_x, point_y) {
        try {
            var client_x = point_x;
            var client_y = point_y;
            if (Math.abs(dgo_zoomlevel - 100) &gt; 4) {
                client_x = Math.ceil(client_x * 100 / dgo_zoomlevel);
                client_y = Math.ceil(client_y * 100 / dgo_zoomlevel);
            }
            if (!(this.element = window.document.elementFromPoint(client_x, client_y))) return false;
            try {
                var wpb_xray = generate_xray_path(this.element, Help4R.RpickSelector().selector);  // xRay.js
                if (DgoUtils.is_valid_str(wpb_xray.rule)) {
                    //window.document.body.setAttribute("wpb_xray_hotspotAnchor", wpb_xray.rule, 0);
                    this.xray_path = "xray=\"" + window.btoa(JSON.stringify(wpb_xray.rule)) + "\";xps=\"" + wpb_xray.safe + "\";";
                    this.path_safe = wpb_xray.safe;
                    this.element = wpb_xray.elem;
                }
            } catch (err) {
                exception_debugging(err);
            }
            return true;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    recognition_output: function () {
        var obj_rect = "";
        if (this.object_sub_type === "") {
            obj_rect = this.element_rect.left + "," + this.element_rect.top + "," +
                      this.element_rect.right + "," + this.element_rect.bottom;
        } else {
            obj_rect = this.element_rect_str;
        }
        return ("epath|=|" + "" + delimiter +
                "type|=|" + this.object_type + delimiter +
                "rect|=|" + obj_rect + delimiter +
                "eep|=|" + this.eep + this.xray_path + delimiter +
                "name|=|" + "" + delimiter +
                "val|=|" + "" + delimiter +
                "safe|=|" + this.path_safe);
    }
});

var HTMLElementRecognition = new DGO.XRayHTMLElementRecognition();
// ---------------------------------------------------
var HTMLElementRerecognition = new DGO.BaseHTMLElementRerecognition();

DGO.UI5Effect = function () {
    DGO.Effect.call(this);
};
DGO.UI5Effect.prototype = new DGO.Effect();

extendObj(DGO.UI5Effect.prototype, {
    mouse_effect_handler: function (e) {
        try {
            e = e || event;
            if (!e || !e.target) return;

            if (e.type === "mouseover") {
                //console.log("mouseover effect");
                if (DgoEffect.overlay.active === false) return;
                var p = generate_xray_path(e.target, Help4R.RpickSelector().selector);  // xRay.js
                var target_pos = (p &amp;&amp; p.elem) ? p.elem.getBoundingClientRect() : e.target.getBoundingClientRect();

                var overlay_style = DgoEffect.get_overlay().style;
                overlay_style.cssText = _HELP4_CONTROL_CAPTURERECT_CSS + ((p &amp;&amp; p.safe === 1.0) ? _HELP4_SAFE_CSS : "");
                overlay_style.visibility = "";
                overlay_style.left = target_pos.left.toString() + "px";
                overlay_style.top = target_pos.top.toString() + "px";
                overlay_style.width = (target_pos.right - target_pos.left).toString() + "px";
                overlay_style.height = (target_pos.bottom - target_pos.top).toString() + "px";

                //console.log("over " + e.target.tagName + ":" + e.target.className + " pos: " + target_pos.left + "x" + target_pos.top + ((p &amp;&amp; p.elem) ? " (selector element)" : " (event target)"));
                //console.log("effect active: " + DgoEffect.overlay.active + " timestamp: " + DgoEffect.overlay.timestamp);
                //console.log("rule: " + p.rule.toString());
                //console.log("selector: " + Help4R.RpickSelector().name);   // xRay.js

                // prevent other mouseover effects
                e.cancelBubble = true;
            }
        } catch (err) { exception_debugging(err); console.log(err.stack); }
    }

});

var DgoEffect = DgoEffect || new DGO.UI5Effect();



// include file: ../UI5_Library/script.js

/// &lt;reference path="../common/common_script.js/&gt;
// ============================== SAP UI5 ===========================================
DGO.UI5Library = function () {
    DGO.HTMLBasic.call(this);
};

DGO.UI5Library.prototype = new DGO.HTMLBasic();

extendObj(DGO.UI5Library.prototype, {

    check_handler: function (type) {    // DGO.profile.check_handler(type) replaces dgo_check_handler(type)
        var valid_tags = [
            "AsapUiLnk", "AsapDkLnk", "AsapUiDlgCloseBtn",
            "AsapUiUx3NavBarItem", "AsapUiUx3ShellTool sapUiUx3ShellTool-search",
            "BUTTONsapUiBtn sapUiBtnNorm sapUiBtnS sapUiBtnStd sapUiMenuButton",
            "BUTTONsapUiBtn sapUiBtnFixedWidth sapUiBtnNorm sapUiBtnS sapUiBtnStd",
            "BUTTONsapUiBtn sapUiBtnNorm sapUiBtnS sapUiBtnStd",
            "BUTTONsapUiBtn sapUiBtnAccept sapUiBtnNoGradient sapUiBtnNorm sapUiBtnS sapUiBtnStd",
            "BUTTONsapUiBtn sapUiBtnFixedWidth sapUiBtnNoGradient sapUiBtnNorm sapUiBtnS sapUiBtnStd",
            "BUTTONsapUiBtn sapUiBtnFixedWidth sapUiBtnNoGradient sapUiBtnNorm sapUiBtnReject sapUiBtnS sapUiBtnStd",
            "BUTTONsapUiBtn sapUiBtnIconOnly sapUiBtnLite sapUiBtnNoGradient sapUiBtnS sapUiTreeExp sapUiBtnStd",
            "BUTTONsapUiBtn sapUiBtnIconOnly sapUiBtnLite sapUiBtnNoGradient sapUiBtnS sapUiTreeCol sapUiBtnStd",
            "BUTTONsapUiBtn sapUiBtnNoGradient sapUiBtnNorm sapUiBtnS sapUiBtnStd",
            "BUTTONsapUiBtn sapUiBtnNoGradient sapUiBtnNorm sapUiBtnS sapUiBtnStd sapUiBtnFoc",
            "BUTTONsapUiBtn sapUiBtnNoGradient sapUiBtnNorm sapUiBtnS sapUiToggleBtn sapUiBtnStd sapUiToggleBtnPressed",
            "DIVL Vertical sapHcmECImageHolder", "DIVL Vertical sapHcmECAttrName", "DIVL Vertical sapHcmEC",
            "DIVL Vertical sapHcmECSubtitle", "DIVL Vertical sapHcmEC sapHcmReportLine",
            "DIVsapMBtnFocusDiv",
            "DIVsapMBtnDefault sapMBtnHoverable sapMBtnInner sapMBtnPaddingLeft sapMBtnPaddingRight sapMFocusable",
            "DIVsapMCbActiveStateOff sapMCbBg sapMCbHoverable sapMCbMark",
            "DIVsapMCbActiveStateOff sapMCbBg sapMCbHoverable sapMCbMark sapMCbMarkChecked",
            "DIVsapMCbBg sapMCbHoverable sapMCbMark sapMCbMarkChecked",
            "DIVsapMCbBg sapMCbHoverable sapMCbMark",
            "DIVsapMComboBoxBaseArrow",
            "DIVsapMITBText sapMITBTextUpperCase",
            "DIVsapMLIBContent",
            "DIVsapMLIBContent sapMLIBContentMargin",
            "DIVsapMMultiComboBoxArrow",
            "DIVsapMObjLNumber sapMObjLNumberStateNone",
            "DIVsapMRbBOut sapMRbHoverable",
            "DIVsapMRbBInn",
            "DIVsapMRISelector",
            "DIVsapMSLITitle",
            "DIVsapMSLITitleOnly",
            "DIVsapMStdTileTitle",
            "DIVsapMStdTileInfo sapMStdTileInfoNone",
            "DIVsapMTextMaxLine",
            "DIVsapUiMnuItmTxt",
            "DIVsapUiSearchFieldIco",
            "DIVsapUiTableCol",
            "DIVsapUiTableColRowHdr sapUiTableSelAll",
            "DIVsapUiTableColRowHdr",
            "DIVsapUiTableColRowHdrIco",
            "DIVsapUiTfComboIcon",
            "DIVsapUiTfDateIcon",
            "DIVsapUiFeederInput",
            "DIVsapUshellTile",
            "LIsapUshellTile",
            "DIVviz-controls-switchbar-dropdown-arrow",
            "DIVviz-controls-switchbar-dropdown-arrow-icon viz-controls-common-havanaSharedSprite16-mask",
            "IMGSPANsapUiTreeIcon:sapUiTreeNodeContent",
            "IMGDIVsapUiImg sapUiTableColIconsOrder",
            "IMGDIVsapUiTfValueHelpIcon sapUiTfValueHelpRegularIcon",
            "INPUTtextsapUiTf sapUiTfBack sapUiTfBrd sapUiTfReq sapUiTfStd",
            "INPUTtextsapMInputBaseInner",
            "INPUTtextsapUiTf sapUiTfInner",
            "INPUTtextsapUiTf sapUiTfBack sapUiTfBrd sapUiTfStd",
            "INPUTtextsapUiTf sapUiTfBack sapUiTfBrd sapUiTfStd sapUiTfFoc",
            "LABELsapUiCbNoText",
            "LABELsapUiLbl sapUiLblNowrap",
            "SPANpreview previewColor2 sapUiIcon sapUiIconMirrorInRTL",
            "SPANsapMBarChild sapUiIcon sapUiIconMirrorInRTL",
            "SPANsapMBtnCustomIcon sapMBtnIcon sapUiIcon sapUiIconMirrorInRTL",
            "SPANsapMInputValHelpInner sapUiIcon sapUiIconMirrorInRTL",
            "SPANsapMPanelExpandableIcon sapUiIcon sapUiIconMirrorInRTL",
            "SPANsapMPanelExpandableIcon sapMPanelExpandableIconExpanded sapUiIcon sapUiIconMirrorInRTL",
            "SPANsapMPanelExpandableIcon sapUiIcon sapUiIconMirrorInRTL sapMPanelExpandableIconExpanded",
            "SPANsapMSltArrow",
            "SPANsapMSltIcon sapUiIcon sapUiIconMirrorInRTL",
            "SPANsapMSLIImgFirstIcon sapUiIcon sapUiIconMirrorInRTL",
            "SPANsapMObjStatusText",
            "SPANsapUiBtnTxt",
            "SPANsapUiMenuButtonIco",
            "SPANsapUiLbxITxt",
            "SPANsapUiTreeNodeContent",
            "SPANsapUiTableTreeIcon sapUiTableTreeIconNodeClosed",
            "SPANsapUiTableTreeIcon sapUiTableTreeIconNodeOpen",
            "SPANsapUiUx3ExactLstHeadTopTxtTxt",
            // ================================ SF ================================ 
            "BUTTONbizXSFB bizXSFST",
            "AglobalNavigationItem sapMBarChild sapMLnkMaxWidth sapMTBShrinkItem",
            "BUTTONglobalPlacematText sapMBtn surjUserPhoto surjUserPhotoCircle surjUserPhotoName-EAST",
            "INPUTtextsfPaginatorPageSwitch",
            "INPUTtextsearchBox",
            "BUTTONsfmultiselectbutton sfmultiselectitem",
            "INPUTtextsfTextInput msClearSearchIndicator searchIndicator",
            "Alink filterText",
            "Alink sortText sortDate",
            "Alink sortText sortPriority",
            "SPANrefreshCarousel iconFontSupport reconmendationTileActionButton",
            "SPANhorizontalRecommendationFilter iconFontSupport reconmendationTileActionButton",
            "AglobalFloatLeft globalTileHeaderIcon shrink globalIconFont1Support",
            "SPANglobalArrowColor sfTriangle globalIconFont1Support globalIconFont1 directionbottom",
            "AglobalIconFont1Support sfCheckBoxInputBox globalMenuItemEnhancedElement left",
            "AglobalIconFont1Support sfCheckBoxInputBox globalMenuItemEnhancedElement left checked",
            "SPANui5",
            "BUTTONglobalRoundedCornersXSmall globalSecondaryButton buttonDefault",
            "BUTTONsapMComboBoxArrow sapMComboBoxBaseArrow sapMComboBoxTextFieldArrow",
            "INPUTtextsapMComboBoxInner sapMComboBoxTextFieldInner sapMComboBoxTextFieldInnerWidthExtraPadding sapMInputBaseInner",
            "LABELsapMInputBasePlaceholder",
            "BUTTONsapMComboBoxBaseArrow sapMComboBoxTextFieldArrow sapMMultiComboBoxArrow",
            
         
            // ================================ Fiori====================================
            "Adwb dwb1 dwb-e",
            "BUTTONsapMBtn sapMBtnDefault sapMBtnDesktop sapMBtnPaddingRight sapMFocusable",
            "BUTTONsapUiBtn sapUiBtnEmph sapUiBtnNorm sapUiBtnS sapUiBtnStd",
            "BUTTONurEdf2HlpDate",
            "DIVsapUshellTileBase",
            "DIVsapUshellLockedTile sapUshellTile",
            "DIVsapMPullDown sapMPullDownNontouch",
            "DIVsapMBtnHoverable sapMBtnInner sapMBtnPaddingLeft sapMBtnPaddingRight sapMBtnTransparent sapMFocusable",
            "DIVdw-i",
            "DIVsapMStdTileInfo sapMStdTileInfoError",
            "DIVkpiValueWrapper semanticColor",
            "DIVdimensionName",
            "DIVAuto Error sapSuiteBCBarValue",
            "DIVsapMObjLTopRow",
            "DIVsapMSFB sapMSFS",
            "DIVsapMSFB sapMSFR",
            "DIVTecItemTileInfo",
            "DIVTecItemTileTitle",
            "DIVTecItemTileContent",
            "DIVurTedWhl",
            "H3sapUshellTileBaseTitle",
            "H4sapUshellTileBaseSubtitle",
            "INPUTtexturEdf2TxtEnbl",
            "INPUTtexturEdf2TxtEnbl urEdf2TxtHlp",
            "SPANsapMBtnCustomIcon sapUiIcon",
            "SPANsapMPullDownIcon",
            "SPANsapMPullDownText",
            "SPANsapUiIcon",
            "LIsapUshellTile",
            "SPANsapMBtnCustomIcon sapUiIcon sapUiIconMirrorInRTL",
            "SPANsapMBtnContentSpan",
            "SPANsapMPullDownText",
            "SPANsapUIMeLegendIcon sapUiIcon sapUiIconMirrorInRTL sapUiIconPointer",
            "SPAN:dwb-e dwwb dwwbm",
            "SPAN:dwb-e dwwb dwwbp",
            "SPANsapMText sapMTextMaxWidth title",
            "SPANsapMText sapMTextBreakWord sapMTextMaxWidth value",
            "SPAN:sapUiUfdShellHeadItm sapUiUfdShellHeadItmSep",
            "SPANsapMITBFilterIcon sapMITBFilterNeutral sapUiIcon sapUiIconMirrorInRTL",
            "SPANsapMITBFilterDefault sapMITBFilterIcon sapUiIcon sapUiIconMirrorInRTL",
            "SPANsapUiUfdShellHeadUsrItmExp",
            "SPANsapMTextMaxLine",
            "SPANsapMInputValHelpInner sapUiIcon sapUiIconMirrorInRTL sapUiIconPointer",
            "TDurST3TD urCursorClickable urST3Cl"
        ];
        if (type.search("AsapUiPagBtn sapUiPag") &gt;= 0 ||
            type.search("BUTTONsapSuiteUiCommonsSplitButton-menuButton sapUiBtn sapUiBtn") &gt;= 0 ||
            type.search("SPANsapMeCalendarPrevious sapUiIcon sapUiIconMirrorInRTL") &gt;= 0 ||
            type.search("DIVsapMStdTileNum") &gt;= 0 ||
            type.search("SPANsapMeCalendarNext sapUiIcon sapUiIconMirrorInRTL") &gt;= 0)
        {
            return true;
        }
        return valid_tags.indexOf(type) &gt;= 0 || DGO.HTMLBasic.prototype.check_handler.call(this, type);
    },
    convert_to_compat: function (type) {
        var new_type = type;
        switch (type) {
            case "DIVsapMCbActiveStateOff sapMCbBg sapMCbHoverable sapMCbMark sapMCbMarkChecked":
            case "DIVsapMCbBg sapMCbHoverable sapMCbMark sapMCbMarkChecked":
                new_type = "DIVsapMCbBg sapMCbHoverable sapMCbMark";
                break;
            case "DIVsapMLIBContent":
            case "AsapUiLnk":
            case "SPANsapMSLIImgFirstIcon sapUiIcon sapUiIconMirrorInRTL":
            case "SPANpreview previewColor2 sapUiIcon sapUiIconMirrorInRTL":
            case "SPANsapUiTableTreeIcon sapUiTableTreeIconNodeOpen":
            case "SPANsapUiTableTreeIcon sapUiTableTreeIconNodeClosed":
            case "SPANsapMPanelExpandableIcon sapUiIcon sapUiIconMirrorInRTL sapMPanelExpandableIconExpanded":
            case "SPANsapMPanelExpandableIcon sapMPanelExpandableIconExpanded sapUiIcon sapUiIconMirrorInRTL":
            case "SPANsapMPanelExpandableIcon sapUiIcon sapUiIconMirrorInRTL":
            case "DIVsapMPullDown sapMPullDownNontouch":
            case "SPANsapMPullDownText":
            case "DIVTecItemTileContent":
            case "SPANsapMITBFilterIcon sapMITBFilterNeutral sapUiIcon sapUiIconMirrorInRTL":
            case "Adwb dwb1 dwb-e":
            case "SPAN:dwb-e dwwb dwwbp":
            case "SPAN:dwb-e dwwb dwwbm":
            case "DIVdw-i":
            case "SPANsapUIMeLegendIcon sapUiIcon sapUiIconMirrorInRTL sapUiIconPointer":
            case "SPAN:sapUiUfdShellHeadItm sapUiUfdShellHeadItmSep":
            case "DIVsapMSFB sapMSFR":
            case "DIVsapMSFB sapMSFS":
            case "DIVsapUshellTileBase":
            case "DIVsapMRISelector":
            case "DIVL Vertical sapHcmEC sapHcmReportLine":
            case "DIVL Vertical sapHcmEC":
            case "SPANsapMITBFilterDefault sapMITBFilterIcon sapUiIcon sapUiIconMirrorInRTL":
                new_type = "DIVsapMSLITitle";
                break;
            case "DIVsapUshellLockedTile sapUshellTile":
                new_type = "DIVsapUshellTile";
                break;
            case "SPANsapMText sapMTextBreakWord sapMTextMaxWidth value":
            case "DIVAuto Error sapSuiteBCBarValue":
            case "DIVdimensionName":
            case "SPANsapMBtnCustomIcon sapUiIcon":
            case "DIVsapMStdTileInfo sapMStdTileInfoError":
            case "DIVkpiValueWrapper semanticColor":
            case "SPANsapMText sapMTextMaxWidth title":
            case "DIVsapMStdTileInfo sapMStdTileInfoNone":
            case "SPANsapMBtnCustomIcon sapUiIcon sapUiIconMirrorInRTL":
            case "H3sapUshellTileBaseTitle":
            case "H4sapUshellTileBaseSubtitle":
            case "DIVL Vertical sapHcmECSubtitle":
            case "SPANsapMBtnContentSpan":
                new_type = "DIVsapMStdTileTitle";
                break;
            case "DIVTecItemTileInfo":
            case "DIVL Vertical sapHcmECAttrName":
            case "DIVTecItemTileTitle":
                new_type = "DIVsapMObjLTopRow";
                break;
            case "LABELsapMInputBasePlaceholder":
                new_type = "INPUTtextsapMComboBoxInner sapMComboBoxTextFieldInner sapMComboBoxTextFieldInnerWidthExtraPadding sapMInputBaseInner";
                break;
            case "AglobalIconFont1Support sfCheckBoxInputBox globalMenuItemEnhancedElement left checked":
            case "AglobalIconFont1Support sfCheckBoxInputBox globalMenuItemEnhancedElement left":
                new_type = "LABELsapUiCbNoText";
                break;
            case "AsapUiUx3ShellTool sapUiUx3ShellTool-search":
            case "DIVsapUiSearchFieldIco":
            case "SPANsapMBarChild sapUiIcon sapUiIconMirrorInRTL":
            case "DIVsapUiTableColRowHdr sapUiTableSelAll":
            case "Alink sortText sortDate":
            case "Alink sortText sortPriority":
            case "SPANrefreshCarousel iconFontSupport reconmendationTileActionButton":
            case "SPANhorizontalRecommendationFilter iconFontSupport reconmendationTileActionButton":
            case "AglobalFloatLeft globalTileHeaderIcon shrink globalIconFont1Support":
                new_type = "DIVsapUiTableColRowHdr";
                break;
            case "DIVsapMITBText sapMITBTextUpperCase":
                new_type = "AsapUiUx3NavBarItem";
                break;
            case "INPUTtextsapUiTf sapUiTfInner":
            case "INPUTtextsapUiTf sapUiTfBack sapUiTfBrd sapUiTfStd":
            case "INPUTtextsapMInputBaseInner":
            case "DIVsapUiFeederInput":
            case "INPUTemail":
            case "INPUTsearch":
            case "INPUTtel":
            case "INPUTurl":
            case "INPUTnumber":
            case "INPUTtextsapUiTf sapUiTfBack sapUiTfBrd sapUiTfReq sapUiTfStd":
            case "INPUTtextsapUiTf sapUiTfBack sapUiTfBrd sapUiTfStd sapUiTfFoc":
                new_type = "DIVsapUiFeederInput";
                break;
            case "INPUTtextsearchBox":
            case "INPUTtextsfTextInput msClearSearchIndicator searchIndicator":
                new_type = "INPUTtextsfPaginatorPageSwitch";
                break;
            case "SPANsapUiLbxITxt":
            case "IMGDIVsapUiImg sapUiTableColIconsOrder":
            case "DIVsapMLIBContent sapMLIBContentMargin":
                new_type = "DIVsapUiTableCol";
                break;
            case "BUTTONsapUiBtn sapUiBtnNoGradient sapUiBtnNorm sapUiBtnS sapUiBtnStd":
            case "BUTTONsapUiBtn sapUiBtnEmph sapUiBtnNorm sapUiBtnS sapUiBtnStd":
            case "DIVsapMBtnDefault sapMBtnHoverable sapMBtnInner sapMBtnPaddingLeft sapMBtnPaddingRight sapMFocusable":
            case "BUTTONsapUiBtn sapUiBtnNoGradient sapUiBtnNorm sapUiBtnS sapUiBtnStd sapUiBtnFoc":
            case "BUTTONsapUiBtn sapUiBtnAccept sapUiBtnNoGradient sapUiBtnNorm sapUiBtnS sapUiBtnStd":
            case "BUTTONsapUiBtn sapUiBtnFixedWidth sapUiBtnNoGradient sapUiBtnNorm sapUiBtnS sapUiBtnStd":
            case "BUTTONsapUiBtn sapUiBtnFixedWidth sapUiBtnNoGradient sapUiBtnNorm sapUiBtnReject sapUiBtnS sapUiBtnStd":
            case "BUTTONsapMBtn sapMBtnDefault sapMBtnDesktop sapMBtnPaddingRight sapMFocusable":
            case "BUTTONsapUiBtn sapUiBtnNorm sapUiBtnS sapUiBtnStd":
            case "DIVsapMBtnHoverable sapMBtnInner sapMBtnPaddingLeft sapMBtnPaddingRight sapMBtnTransparent sapMFocusable":
            case "BUTTONsapUiBtn sapUiBtnFixedWidth sapUiBtnNorm sapUiBtnS sapUiBtnStd":
            case "BUTTONsapUiBtn sapUiBtnNoGradient sapUiBtnNorm sapUiBtnS sapUiToggleBtn sapUiBtnStd sapUiToggleBtnPressed":
            case "DIVsapMBtnFocusDiv":
            case "AglobalNavigationItem sapMBarChild sapMLnkMaxWidth sapMTBShrinkItem":
            case "BUTTONglobalRoundedCornersXSmall globalSecondaryButton buttonDefault":
                new_type = "AsapUiDlgCloseBtn";
                break;
            case "DIVsapUiTfComboIcon":
            case "DIVsapMComboBoxBaseArrow":
            case "DIVsapMMultiComboBoxArrow":
            case "SPANsapUiUx3ExactLstHeadTopTxtTxt":
            case "BUTTONsapSuiteUiCommonsSplitButton-menuButton sapUiBtn sapUiBtnNorm sapUiBtnS sapUiBtnStd sapUiMenuButton":
            case "BUTTONsapUiBtn sapUiBtnNorm sapUiBtnS sapUiBtnStd sapUiMenuButton":
            case "DIVviz-controls-switchbar-dropdown-arrow":
            case "SPANsapUiUfdShellHeadUsrItmExp":
            case "SPANsapMSltIcon sapUiIcon sapUiIconMirrorInRTL":
            case "BUTTONglobalPlacematText sapMBtn surjUserPhoto surjUserPhotoCircle surjUserPhotoName-EAST":
            case "DIVsapUiTfComboIcon":
            case "SPANui5":
            case "BUTTONsapMComboBoxBaseArrow sapMComboBoxTextFieldArrow sapMMultiComboBoxArrow":
            case "BUTTONsapMComboBoxArrow sapMComboBoxBaseArrow sapMComboBoxTextFieldArrow":
                new_type = "SPANsapMSltArrow";
                break;
            case "BUTTONsfmultiselectbutton sfmultiselectitem":
                new_type = "BUTTONbizXSFB bizXSFST";
                break;
            case "DIVsapMGTContent":
            case "DIVOneByOne sapMGTHdrContent":
            case "DIVsapMGTFocusDiv":
            case "DIVsapMGTWithoutImageHoverOverlay":
            case "DIVOneByOne sapMGT sapMPointer":
            case "DIVsapUiJSView sapUiView sapUiViewDisplayBlock":
            case "DIVsapUshellTileInner":
                new_type = "LIsapUshellTile"; 
                break;
            case "DIVsapMLIBContent":
            case "DIVsapMObjLTopRow":
            case "DIVsapMObjLNumber sapMObjLNumberStateNone":
            case "SPANsapMTextMaxLine":
            case "SPANsapMObjLTitle sapMText sapMTextMaxWidth sapUiSelectable":
            case "DIVsapMObjLNumberStateNone sapMObjLNumberUnit":
            case "DIVsapMObjLNumberDiv":
                new_type = "LIsapMLIB sapMLIB-CTX sapMLIBActionable sapMLIBFocusable sapMLIBHoverable sapMLIBLegacyOutline sapMLIBSelected sapMLIBShowSeparator sapMLIBTypeInactive sapMObjLItem sapMObjLListModeDiv"; 
                break;
            case "BUTTONsapSuiteUiCommonsSplitButton-menuButton sapUiBtn sapUiBtnEmph sapUiBtnNorm sapUiBtnS sapUiMenuButton sapUiBtnStd":
                new_type = "BUTTONsapSuiteUiCommonsSplitButton-menuButton sapUiBtn sapUiBtnLite sapUiBtnS sapUiMenuButton sapUiBtnStd";
                break;
            default:
                if (type.search("SPANsapMeCalendarPrevious sapUiIcon sapUiIconMirrorInRTL") &gt;= 0 || type.search("SPANsapMeCalendarNext sapUiIcon sapUiIconMirrorInRTL") &gt;= 0) {
                    new_type = "DIVsapMSLITitle";
                } else if (type.search("DIVsapMStdTileNum") &gt;= 0) {
                    new_type = "DIVsapMObjLTopRow";
                } else if (type.search("AsapUiPagBtn sapUiPag") &gt;= 0) {
                    new_type = "AsapUiDlgCloseBtn";
                } else if (type.search("BUTTONsapSuiteUiCommonsSplitButton-menuButton sapUiBtn sapUiBtn") &gt;= 0) {
                    new_type = "BUTTONsapSuiteUiCommonsSplitButton-menuButton sapUiBtn sapUiBtnLite sapUiBtnS sapUiMenuButton sapUiBtnStd";
                }
        }
        return new_type !== type ? new_type : DGO.HTMLBasic.prototype.convert_to_compat.call(this, type);
    },
    tile_text: function (e) {
        try {
            if (e) {
                var aElements = typeof $ === "function" ? $(e).find("H3") : null;
                if (aElements &amp;&amp; typeof aElements[0] !== "undefined" &amp;&amp; typeof aElements[0].tagName !== "undefined") {
                    var sAttrValue = aElements[0].innerText;
                    if (DgoProfile.valid_string(sAttrValue)) return sAttrValue;
                }
            }
        } catch (err) { exception_debugging(err); }
        return "";
    }
});
DGO.SAPUI5LibHTMLElementRecognition = function () {
    DGO.HtmlBasicHTMLElementRecognition.call(this);
};

DGO.SAPUI5LibHTMLElementRecognition.prototype = new DGO.HtmlBasicHTMLElementRecognition();

extendObj(DGO.SAPUI5LibHTMLElementRecognition.prototype, {
    get_element_from_point: function (point_x, point_y) {
        try {
            var get_elem = DGO.HtmlBasicHTMLElementRecognition.prototype.get_element_from_point.call(this, point_x, point_y);
            if (!get_elem) {
                var client_x = point_x;
                var client_y = point_y;
                if (Math.abs(dgo_zoomlevel - 100) &gt; 4) {
                    client_x = Math.ceil(client_x * 100 / dgo_zoomlevel);
                    client_y = Math.ceil(client_y * 100 / dgo_zoomlevel);
                }
                if (!(this.element = window.document.elementFromPoint(client_x, client_y))) return false;
                this.element = DgoProfile.check_accessKey(this.element);
                if (this.element &amp;&amp; this.element.tagName === "B") this.element = this.element.parentElement;
                // xray
                var closest_exists = typeof $ === "function" &amp;&amp; typeof $.closest === "function";
                var aElements = closest_exists ? $(this.element).closest(".sapUshellTile") : null;
                if (aElements &amp;&amp; aElements[0] !== undefined &amp;&amp; aElements[0].tagName !== undefined) {
                    this.element = aElements[0];
                }
                return true;
            }
            return get_elem;
        } catch (err) { exception_debugging(err); }
        return false;
    }
});

var HTMLElementRecognition = new DGO.SAPUI5LibHTMLElementRecognition();

// =============================================== Eep ================================================ //
DGO.SAPUI5LibEepUtils = function () {
    DGO.BaseEepUtils.call(this);
};

DGO.SAPUI5LibEepUtils.prototype = new DGO.BaseEepUtils();

extendObj(DGO.SAPUI5LibEepUtils.prototype, {
    Eep_qaElement_: function (obj, atts, options) {
        if (!obj) return false;
        try {
            var match_width = true;
            var rc;
            var obj_Rect = obj.getBoundingClientRect();
            var objht = parseInt(obj_Rect.bottom) - parseInt(obj_Rect.top);
            var objwt = parseInt(obj_Rect.right) - parseInt(obj_Rect.left);
            if (true !== (rc = this.Eep_qaInputElement_(obj, atts))) {
                return rc;
            }
            if (atts.src) {
                if (!obj.src || (obj.src !== atts.src)) {
                    return "!=SRC";
                } else {
                    match_width = false;
                }
            }
            if (!options || options &amp;&amp; options.eep_use_text === "true") {
                if (true !== (rc = this.Eep_qaElementText_(obj, atts, options))) {
                    return rc;
                } else {
                    match_width = false;
                }
            }
            if (atts.tiletext) {
                if (obj.className &amp;&amp; obj.className === "sapUshellTile") {
                    var curr_tile = DgoProfile.tile_text(obj);
                    if (curr_tile === atts.tiletext) {
                        return true;
                    } else {
                        return "!=tile";
                    }
                } else {
                    return "!=tile";
                }
            }
            if (atts.gptitle) {
                var gptitle_matched = false;
                var gp_elm = obj.parentNode.parentNode;
                if (gp_elm.tagName === "BUTTON") {
                    var gptitle = gp_elm.title;
                    if (DgoUtils.is_valid_str(gptitle) &amp;&amp; atts.gptitle === gptitle) {
                        gptitle_matched = true;
                    }
                }
                if (!gptitle_matched) {
                    return "!=gptitle";
                }
            }
            if (atts.parents) {
                var wpb_xray = generate_xray_path(obj, Help4R.RpickSelector().selector);
                if (!DgoUtils.is_valid_str(wpb_xray.rule) || (atts.parents !== window.btoa(JSON.stringify(wpb_xray.rule)))) {
                    return "!=parents";
                }
            }
            if (atts.id) {
                if ((obj.id &amp;&amp; (obj.id !== atts.id) &amp;&amp; !this.partial_id_comp_(atts.id, obj.id)) || !obj.id) {
                    return "!=ID";
                } else {
                    match_width = false;
                }
            } else if (obj.id) {
                var el;
                var doc = DgoProfile.get_doc_from_elem(obj);
                if (doc &amp;&amp; doc.all &amp;&amp; (el = doc.all[obj.id]) &amp;&amp; typeof el.length === "number" &amp;&amp; el.length &gt; 1) {
                    // mySAP, i.e., has lots of duplicate IDs
                } else {
                    return "!=ID";
                }
            }
            if (atts.ht &amp;&amp; atts.wt) {
                if (!objht || !objwt ||
                    (match_width &amp;&amp; (objwt &lt;= (atts.wt - 2) || objwt &gt;= (atts.wt + 2))) ||
                    (objht &lt;= (atts.ht - 2) || objht &gt;= (atts.ht + 2))) {
                    return "!=DIMENSIONS";
                }
            }
        } catch (err) {
            exception_debugging(err);
            return false;
        }
        return true;
    },
    Eep_generateAttsString_: function (obj, options, tags4text, text_truncation) {
        var str = DGO.BaseEepUtils.prototype.Eep_generateAttsString_.call(this, obj, options, tags4text, text_truncation);
        var add_parents_info = true;
        if (str.search("firstText") != -1) {
            add_parents_info = false;
        }
        if (add_parents_info &amp;&amp; (obj.tagName == "SPAN") &amp;&amp; obj.id &amp;&amp; (obj.id.search("button") != -1)) {
            var gp_elm = obj.parentNode.parentNode;
            if (gp_elm.tagName == "BUTTON") {
                var gptitle = gp_elm.title;
                if (DgoUtils.is_valid_str((gptitle))) {
                    str+=(',gptitle:' + gptitle.asJSstring());
                    add_parents_info = false;
                }
            }
        }
        if (obj.className &amp;&amp; obj.className === "sapUshellTile") {
            var tile_txt = DgoProfile.tile_text(obj);
            if (tile_txt) {
                add_parents_info = false;
                str+=(',tiletext:' + tile_txt.asJSstring());
            }
        }
        // Add xRay Path.
        if (add_parents_info &amp;&amp; typeof generate_xray_path === "function") {
            var wpb_xray = generate_xray_path(obj, Help4R.RpickSelector().selector);
            if (DgoUtils.is_valid_str(wpb_xray.rule)) {
                var en_xray_path = window.btoa(JSON.stringify(wpb_xray.rule));
                str+=(',parents:' + en_xray_path.asJSstring());
            }
        }
        return str;
    }
});

var EepUtils = new DGO.SAPUI5LibEepUtils();

function dgo_tile_text(e) {
    return DgoProfile.tile_text(e);
}

function GetProductInfoAttributes() {
    var prod_info = "";
	if (Help4 &amp;&amp; Help4.getController()) {
		prod_info = "name" + inner_delimiter + 
					DgoUtils.trim(Help4.getController()._params.product) + outer_delimiter +
					"version" + inner_delimiter + 
					DgoUtils.trim(Help4.getController()._params.version) + outer_delimiter +
					"system" + inner_delimiter + 
					DgoUtils.trim(Help4.getController()._params.system) + outer_delimiter;
	}
	return prod_info;
}

//-------------------------------------------------------------------------------------------------//


// include file: ../HTMLBasic/xRay.js

// NEEDS TO BE LOADED BEFORE SELECTORS, DO NOT CHANGE THE INCLUDE ORDER IN PROFILE

(function () {
    if (window.Help4R) {
        // already loaded?
    } else {
        window.Help4R = {
            selector: { methods: {} },
            RisElementBlackListed: RisElementBlackListed,
            RpickSelector: RpickSelector
        }
    }
    //if (window.Help4) {
    //    Help4.RisElementBlackListed = RisElementBlackListed;
    //    Help4.RpickSelector = RpickSelector;
    //} else {
    //    window.Help4 = {
    //        MAIN_CLASS: 'help4',
    //        CLASS_PREFIX: 'help4-',
    //        VERSION: '2.0',
    //        selector: {methods: {}},
    //        $: _$,
    //        RisElementBlackListed: RisElementBlackListed,
    //        RpickSelector: RpickSelector
    //    };
    //    function _$(selector) {
    //        var nodes = document.querySelectorAll(selector);
    //        return Array.prototype.slice.call(nodes, 0);
    //    }
    //}

    var H4S = Help4R.selector;

    function RisElementBlackListed(elem, blacklist) {
        var el = elem;

        while (el.nodeType === 1) {
            // blacklist test
            var nn = el.nodeName.toLowerCase();
            if (blacklist[nn] === 1) return null;

            if (nn === 'button' &amp;&amp; el !== elem) return el;

            el = el.parentNode;
        }

        return elem;
    }

    //function RgetSelector(elem) {
    //    // get the selector
    //    var selector = null;
    //    for (var i = 0, r = Help4.selector.Fiori.rules, l = r.length; i &lt; l; i++) {
    //        var m = Help4.selector.methods[r[i]];
    //        if (!m) continue;

    //        var v = m.getSelector(elem);
    //        if (v) {
    //            selector = {
    //                rule: r[i],
    //                value: v,
    //                safe: m.safe || false,
    //                elem: m.getElement(v)
    //            };
    //            break;
    //        }
    //    }

    //     ignore empty &amp; bad selections and our own controls
    //    return selector !== null &amp;&amp; selector.elem !== null ? selector : null;
    //     return selector !== null &amp;&amp; selector.elem !== null &amp;&amp; H4C.find(selector.elem) === null ? selector : null;
    //}

    function RpickSelector() {
        if (window.sap) {
            if (typeof sap.fiori === "object") {
                return {
                    "selector": H4S.Fiori,
                    "name": "Fiori"
                };
            } else if (window.sap.ui &amp;&amp; typeof sap.ui === "object") {
                return {
                    "selector": H4S.UI5,
                    "name": "UI5"
                };
            }
        }
        return {
            "selector": H4S.Shell,
            "name": "Shell"
        };
    }

})();

var gen_fiori_xray_path = function (elem) {
    try {
        if (elem.nodeType !== 1) elem = elem.parentNode;  // IE10
        var H4S = Help4R.selector;
        if ((elem = Help4R.RisElementBlackListed(elem, H4S.Fiori.blacklist)) !== null) {  // is there a better way?
            var s = H4S.Selector.getSelector(elem, H4S.Fiori.rules);
            if (s) {
                return {
                    'rule': s.value,
                    'safe': s.safe ? 1.0 : 0.5,
                    'elem': s.elem
                }
            }
        }
    } catch (err) {
        console.log(err.stack);
    }
    return {
        'rule': '',
        'safe': 0,
        'elem': elem
    };
};

var generate_xray_path = function (elem, selector) {
    try {
        if (elem.nodeType !== 1) elem = elem.parentNode;  // IE10
        if ((elem = Help4R.RisElementBlackListed(elem, selector.blacklist)) !== null) {
            var s = Help4R.selector.Selector.getSelector(elem, selector.rules);
            if (s) {
                return {
                    'rule': s.value,
                    'safe': s.safe ? 1.0 : 0.5,
                    'elem': s.elem
                }
            }
        }
    } catch (err) {
        console.log(err.stack);
    }
    return {
        'rule': '',
        'safe': 0,
        'elem': elem
    };
};

// xRay styles
var _HELP4_CONTROL_CAPTURERECT_CSS = 'position: absolute; z-index: 1000001; pointer-events: none; transform: translate(-3px, -3px); border: solid 3px #ffc000; background-color: rgba(255,192,0,0.15);';
var _HELP4_SAFE_CSS = 'border-color: #408600; background-color: rgba(64,134,0,0.15);';

// xRay context functions for page key
var _LAUNCHPAD = 'Home';
var _H4SCREEN = '/h4screen';
var _URL_PARAMS = [
    // pre-hash
    'variant',  // Smart business Apps
    'template',  // configuration apps.
    'helpset',

    // post-hash
    '/variant',
    '/template',
    '/helpset',
    _H4SCREEN
];

function _getUrlInfo() {
    var parse = window.sap ? sap.ushell.Container.getService("URLParsing") : null;
    var locHash = parse ? parse.getHash(location.href) : null;
    return {
        pre: parse ? parse.parseParameters(location.href) : null,  // pre-# url info
        post: parse ? parse.parseShellHash(locHash) : null  // post-# url info
    };
}

function _getScreenId() {
    var info = _getUrlInfo();
    var found = { pre: {}, post: {}, h4screen: '' };

    // check pre-hash params
    if (info.pre != null) {
        for (var i in info.pre) {
            if (info.pre.hasOwnProperty(i) &amp;&amp; _URL_PARAMS.indexOf(i) &gt;= 0) {
                found.pre[i] = info.pre[i];
            }
        }
    }

    // check post-hash params
    if (info.post &amp;&amp; info.post.appSpecificRoute) {
        var pars = {};
        info.post.appSpecificRoute.replace(/([^?=&amp;]+)(=([^&amp;]*))?/g, function (p0, p1, p2, p3) { pars[p1] = p3; });

        for (var i in pars) {
            if (pars.hasOwnProperty(i) &amp;&amp; _URL_PARAMS.indexOf(i) &gt;= 0) {
                if (i === _H4SCREEN) {
                    var res = pars[i].match(/[a-zA-Z0-9\.]{1,64}/)[0];
                    if (res) found.h4screen = ':' + res;
                } else {
                    found.post[i] = pars[i];
                }
            }
        }
    }
    // base url string
    var url;
    if (info.post &amp;&amp; typeof info.post.semanticObject === 'string' &amp;&amp; typeof info.post.action === 'string') {
        url = info.post.semanticObject + '-' + info.post.action;
    } else {
        // shell hash undefined =&gt; assume that user is on launchpad
        url = _LAUNCHPAD;
    }

    // pre-hash string
    var pre = [];
    var preKeys = Object.keys(found.pre).sort();
    for (var i = 0, l = preKeys.length; i &lt; l; i++) {
        pre.push(preKeys[i] + '=' + found.pre[preKeys[i]])
    }
    pre = pre.length &gt; 0 ? pre.join('&amp;') + '#' : '';

    // post-hash string
    var post = [];
    var postKeys = Object.keys(found.post).sort();
    for (var i = 0, l = postKeys.length; i &lt; l; i++) {
        post.push(postKeys[i] + '=' + found.post[postKeys[i]]);
    }
    post = post.length &gt; 0 ? '?' + post.join('?') : '';

    // assemble
    return pre + url + found.h4screen + post;
}


// include file: ../HTMLBasic/selector/Selector.js

// NEVER FORGET: THIS CODE IS ALSO USED WITHIN WPB PRODUCER'S RECOGNITION ENGINE
// WITHIN PRODUCER THERE IS NO SUCH THINGS AS HOTSPOTS, ETC.
//
// MAKE SURE THAT THIS FILE AND ALL METHODS ARE ALWAYS SECURED TO RUN IN PRODUCER ENVIRONMENT!!!

(function () {
    var H4S = Help4R.selector;
    var H4C = Help4R &amp;&amp; Help4R.control;
    var H4H = H4C &amp;&amp; H4C.hotspot;

    H4S.methods.$ = Help4R &amp;&amp; Help4R.$ || _$;  // FOR PRODUCER

    H4S.Shell = {
        blacklist: [],
        rules: ['DataAttrSelector', 'ClassSelector', 'TreeDataAttrSelector']
    };

    H4S.Fiori = {
        blacklist: [],
        rules: ['BlacklistFiori', 'DataAttrSelector', 'IdSelectorUI5', 'ClassSelector', 'TreeDataAttrSelector', 'BindingInfoUI5', 'DomSelectorUI5']
    };

    H4S.UI5 = {
        blacklist: [],
        rules: ['DataAttrSelector', 'IdSelectorUI5', 'ClassSelector', 'TreeDataAttrSelector', 'DomSelectorUI5']
    };

    H4S.Selector = {
        getSelector: _getSelector,  // gets a selector from an element
        getElement: _getElement,  // gets an element from a selector
        getOffset: _getOffset,  // gets recorded click offset for element
        getSelectorPosition: _getSelectorPosition,

        setCaptureMode: _setCaptureMode,
        getCaptureMode: function () { return _ovlRect !== null; },
        toggleCaptureDetails: function () { if (_ovlRect) _ovlRect.toggleInfo(); },
        base64ToUtf8: _base64ToUtf8,
        getRule: _getRule
    };

    // some selectors have been renamed while creating xRay 2.0
    // old content still exists, need to be mapped
    var _LEGACY = {
        IdSelector: 'IdSelectorUI5',
        BindingInfo: 'BindingInfoUI5',
        DomSelector: 'DomSelectorUI5'
    };

    var _ovlRect = null;

    function _$(selector) {
        var nodes = document.querySelectorAll(selector);
        return Array.prototype.slice.call(nodes, 0);
    }

    function _getRule(selector) {
        return selector &amp;&amp; selector.rule ? _LEGACY[selector.rule] || selector.rule : null;
    }

    function _getSelectorPosition(selector /*, params*/) {
        selector = _base64ToUtf8(selector);

        var p = arguments[1] || {};
        var e = p.elem || this.getElement(selector);
        if (!p.offset) p.offset = this.getOffset(selector);
        return Help4.Element.getPosition(e, p);
    }

    function _getSelector(elem, rules) {
        var selector = null;

        // direct hotspot hover/click - assign to same element
        if (H4H &amp;&amp; H4H.Connected &amp;&amp; H4H.Connected.getHotspotAnchor) {
            var anchor = H4H.Connected.getHotspotAnchor(elem);
            selector = anchor ? H4S.Selector.base64ToUtf8(anchor) : null;

            if (selector) {
                var rule = selector.rule = H4S.Selector.getRule(selector);
                selector.elem = rule &amp;&amp; H4S.methods[rule] ? H4S.methods[rule].getElement(selector.value) : null;
            }
        }

        if (!selector || !selector.elem) {
            selector = null;

            // get the selector
            for (var i = 0, l = rules.length; i &lt; l; i++) {
                var m = H4S.methods[rules[i]];
                if (!m) continue;

                var v = m.getSelector(elem);
                if (v === false) break;  // (blacklist) selector says to abort here

                var e = v ? m.getElement(v) : null;
                if (e) {
                    selector = {
                        rule: rules[i],
                        value: v,
                        safe: m.safe || false,
                        elem: e
                    };
                    break;
                }
            }
        }

        // ignore empty &amp; bad selections and our own controls
        return H4C &amp;&amp; H4C.Store &amp;&amp; H4C.Store.find
            ? selector !== null &amp;&amp; H4C.Store.find(selector.elem) === null ? selector : null
            : selector;
    }

    function _getElement(selector) {
        selector = _base64ToUtf8(selector);
        if (selector &amp;&amp; selector.rule) {
            var rule = _getRule(selector);
            return H4S.methods[rule] ? H4S.methods[rule].getElement(selector.value) : null;
        }

        return null;
    }

    function _getOffset(selector) {
        selector = _base64ToUtf8(selector);
        return selector &amp;&amp; selector.offset || null;
    }

    function _utf8ToBase64(selector) {
        try {
            return window.btoa(JSON.stringify(selector));
        } catch (e) {
        }
        return null;
    }

    function _base64ToUtf8(str) {
        if (typeof str === 'string') {
            try {
                return JSON.parse(window.atob(str));
            } catch (e) {
            }
            return null;
        }
        return str;
    }

    function _setCaptureMode(mode /*, config, callback*/) {
        if (mode === true &amp;&amp; !_ovlRect) {
            var co = arguments[1];
            var cb = arguments[2];

            co.onselector = function (eventType, ovl, selector) {
                _setCaptureMode(false);

                // remove all internal information from selector code
                selector = { rule: selector.rule, value: selector.value, safe: selector.safe, offset: selector.offset };

                cb(_utf8ToBase64(selector));
            };
            co.oncancel = function () {
                _setCaptureMode(false);
                cb(null);
            };

            _ovlRect = new H4C.capture.Capture(co);
        } else if (mode === false &amp;&amp; _ovlRect) {
            _ovlRect.destroy();
            _ovlRect = null;
        }
    }
})();

// include file: ../HTMLBasic/selector/methods/Utils.js

// NEVER FORGET: THIS CODE IS ALSO USED WITHIN WPB PRODUCER'S RECOGNITION ENGINE
// WITHIN PRODUCER THERE IS NO SUCH THINGS AS HOTSPOTS, ETC.
//
// MAKE SURE THAT THIS FILE AND ALL METHODS ARE ALWAYS SECURED TO RUN IN PRODUCER ENVIRONMENT!!!

(function () {
    var H4SM = Help4R.selector.methods;

    H4SM.Utils = {
        getElement: _getElement
    };

    // FOR PRODUCER
    var _isVisible = window.Help4R &amp;&amp; Help4R.Element &amp;&amp; Help4R.Element.isVisible || function (elem) {
        if (elem.offsetWidth === 0 || elem.offsetHeight === 0) return false;

        do {
            var s = getComputedStyle(elem);  // returns all attributes as strings
            if (s.display === 'none' ||
                s.opacity == 0 ||  // auto conversion is needed here
                s.visibility === 'hidden') {
                return false;
            }
            elem = elem.parentNode;
        } while (elem.nodeType === 1);

        return true;
    };

    function _getElement(selector) {
        var el = H4SM.$(selector);
        if (!el || !el.length) return null;

        for (var i = 0, c = null; c = el[i++];) {
            if (_isVisible(c)) return c;  // return the 1st visible one
        }
        return el[0];  // none is visible; return the 1st
    }
})();

// include file: ../HTMLBasic/selector/methods/BlacklistFiori.js

// NEVER FORGET: THIS CODE IS ALSO USED WITHIN WPB PRODUCER'S RECOGNITION ENGINE
// WITHIN PRODUCER THERE IS NO SUCH THINGS AS HOTSPOTS, ETC.
//
// MAKE SURE THAT THIS FILE AND ALL METHODS ARE ALWAYS SECURED TO RUN IN PRODUCER ENVIRONMENT!!!

(function () {
    var H4SM = Help4R.selector.methods;

    H4SM.BlacklistFiori = {
        getElement: function () { return null; },
        getSelector: _getSelector
    };

    function _getSelector(elem) {
        // will return false in case some element is blacklisted

        while (elem.nodeType === 1) {
            var nn = elem.nodeName.toLowerCase();

            if (nn === 'td') {
                // &lt;td&gt; are generally forbidden in Fiori
                // but due to UI5 changes they are used as columnheaders in some cases
                // need to be allowed for this purpose
                if (elem.getAttribute('role').toLowerCase() !== 'columnheader') return false;
            }

            elem = elem.parentNode;
        }

        return null;
    }
})();

// include file: ../HTMLBasic/selector/methods/DataAttrSelector.js

// NEVER FORGET: THIS CODE IS ALSO USED WITHIN WPB PRODUCER'S RECOGNITION ENGINE
// WITHIN PRODUCER THERE IS NO SUCH THINGS AS HOTSPOTS, ETC.
//
// MAKE SURE THAT THIS FILE AND ALL METHODS ARE ALWAYS SECURED TO RUN IN PRODUCER ENVIRONMENT!!!

(function () {
    var H4SM = Help4R.selector.methods;

    H4SM.DataAttrSelector = {
        ATTRIBUTES: ['data-help-id', 'data-helpkey', 'data-tilecatalogid'],

        safe: true,

        getElement: H4SM.Utils.getElement,
        getSelector: _getSelector
    };

    function _getSelector(elem) {
        for (var i = 0, a = null; a = H4SM.DataAttrSelector.ATTRIBUTES[i++];) {
            var v = elem.getAttribute(a);

            if (v) {
                var s = elem.nodeName + "[" + a + "='" + v + "']";
                if (H4SM.$(s).length === 1) return s;
            }
        }

        return null;
    }
})();

// include file: ../HTMLBasic/selector/methods/ClassSelector.js

// NEVER FORGET: THIS CODE IS ALSO USED WITHIN WPB PRODUCER'S RECOGNITION ENGINE
// WITHIN PRODUCER THERE IS NO SUCH THINGS AS HOTSPOTS, ETC.
//
// MAKE SURE THAT THIS FILE AND ALL METHODS ARE ALWAYS SECURED TO RUN IN PRODUCER ENVIRONMENT!!!

(function () {
    var H4SM = Help4R.selector.methods;

    H4SM.ClassSelector = {
        safe: true,

        getElement: H4SM.Utils.getElement,
        getSelector: _getSelector
    };

    var _prefix = ['help-id-'];

    function _getSelector(elem) {
        var c = elem.className.split(/\s+/);
        var n = elem.nodeName;

        for (var i = 0, l = c.length; i &lt; l; i++) {
            for (var j = 0, l2 = _prefix.length; j &lt; l2; j++) {
                if (c[i].match('^' + _prefix[j])) {
                    var s = n + '.' + c[i];
                    if (H4SM.$(s).length === 1) return s;
                }
            }
        }

        return null;
    }
})();

// include file: ../HTMLBasic/selector/methods/TreeDataAttrSelector.js

// NEVER FORGET: THIS CODE IS ALSO USED WITHIN WPB PRODUCER'S RECOGNITION ENGINE
// WITHIN PRODUCER THERE IS NO SUCH THINGS AS HOTSPOTS, ETC.
//
// MAKE SURE THAT THIS FILE AND ALL METHODS ARE ALWAYS SECURED TO RUN IN PRODUCER ENVIRONMENT!!!

(function () {
    var H4SM = Help4R.selector.methods;

    H4SM.TreeDataAttrSelector = {
        safe: true,

        getElement: H4SM.Utils.getElement,
        getSelector: _getSelector
    };

    function _getSelector(elem) {
        var i, a, v;

        while (elem.nodeType === 1) {
            for (i = 0, a = null; a = H4SM.DataAttrSelector.ATTRIBUTES[i++];) {
                v = elem.getAttribute(a);
                if (v) {
                    var s = elem.nodeName + "[" + a + "='" + v + "']";
                    if (H4SM.$(s).length === 1) return s;
                }
            }

            elem = elem.parentNode;
        }

        return null;
    }
})();

// include file: ../HTMLBasic/selector/methods/UtilsUI5.js

// NEVER FORGET: THIS CODE IS ALSO USED WITHIN WPB PRODUCER'S RECOGNITION ENGINE
// WITHIN PRODUCER THERE IS NO SUCH THINGS AS HOTSPOTS, ETC.
//
// MAKE SURE THAT THIS FILE AND ALL METHODS ARE ALWAYS SECURED TO RUN IN PRODUCER ENVIRONMENT!!!

(function () {
    var H4SM = Help4R.selector.methods;

    H4SM.UtilsUI5 = {
        filterId: _filterId,
        getDomTree: _getDomTree,
        getIndexOfXmlView: _getIndexOfXmlView
    };

    var _CSS_BLACKLIST = /sapMInputFocused|inspectOk|inspectConflict|sapMITBDisabled|sapMITBSelected|sapMInputBaseError/i;

    function _filterId(id) {
        // id consists of several parts separated by "--"

        // rule 1:
        // each part is considered stable if it does not start with "__"
        // the stable ID is all stable parts from the END

        // rule 2:
        // in case the 1st part contains an unstable ID all other
        // parts containing it are considered unstable

        id = id.split('--');

        if (id.length &gt; 0) {
            var stable = [];
            var rule2 = id[0].substr(0, 2) === '__' ? id[0] : null;

            for (var i = id.length - 1; i &gt;= 0; i--) {
                if (id[i].substr(0, 2) === '__' || rule2 !== null &amp;&amp; id[i].indexOf(rule2) &gt;= 0) {
                    break;  // unstable part reached
                } else {
                    stable.unshift(id[i]);
                }
            }

            return stable.join('--');
        }

        return '';
    }

    function _getDomTree(elem) {
        var n = elem.parentNode;
        var r = [];

        while (n &amp;&amp; n.nodeType === 1) {
            if (r[0]) {
                // update last entry with information about position in subtree
                for (var i = 0, cn = n.children, l = cn.length; i &lt; l; i++) {
                    if (cn[i] === r[0].element) {
                        r[0].position = i + 1;
                        break;
                    }
                }
            }

            // build selector
            // scheme: nodeName[id$='&lt;filteredDomId&gt;'].class1.class2.classX
            var selector = H4SM.IdSelectorUI5.getSelector(n) || n.nodeName;

            var css = n.className.split(' ');
            if (css.length &gt; 0) {
                for (var i = 0, l = css.length; i &lt; l; i++) {
                    var c = css[i].trim();
                    if (!c) continue;

                    if (c.search(_CSS_BLACKLIST) &lt; 0) selector += '.' + c;
                }
            }

            var jq = $(n);  // convert to jQuery

            r.unshift({
                tag: n.nodeName,
                id: n.id,
                classes: css,
                element: n,
                selector: selector,
                unique: $(selector).length === 1,
                control: typeof jq.control === 'function' ? jq.control()[0] : null
            });

            n = n.parentNode;
        }

        return r;
    }

    function _getIndexOfXmlView(domTree) {
        for (var i = domTree.length - 1; i &gt;= 0; i--) {
            if (domTree[i].id &amp;&amp; domTree[i].id.match(/__xmlview\d$/)) {
                return i + 1;
            }
        }
        return 0;
    }
})();

// include file: ../HTMLBasic/selector/methods/IdSelectorUI5.js

// NEVER FORGET: THIS CODE IS ALSO USED WITHIN WPB PRODUCER'S RECOGNITION ENGINE
// WITHIN PRODUCER THERE IS NO SUCH THINGS AS HOTSPOTS, ETC.
//
// MAKE SURE THAT THIS FILE AND ALL METHODS ARE ALWAYS SECURED TO RUN IN PRODUCER ENVIRONMENT!!!

(function () {
    var H4SM = Help4R.selector.methods;

    H4SM.IdSelectorUI5 = {
        safe: true,

        getElement: H4SM.Utils.getElement,
        getSelector: _getSelector
    };

    function _getSelector(elem) {
        if (elem.nodeType === 1 &amp;&amp; elem.id) {
            var i = H4SM.UtilsUI5.filterId(elem.id);
            var s = i ? elem.nodeName + "[id$='" + i + "']" : '';
            if (s &amp;&amp; H4SM.$(s).length === 1) return s;
        }

        return null;
    }
})();

// include file: ../HTMLBasic/selector/methods/BindingInfoUI5.js

// NEVER FORGET: THIS CODE IS ALSO USED WITHIN WPB PRODUCER'S RECOGNITION ENGINE
// WITHIN PRODUCER THERE IS NO SUCH THINGS AS HOTSPOTS, ETC.
//
// MAKE SURE THAT THIS FILE AND ALL METHODS ARE ALWAYS SECURED TO RUN IN PRODUCER ENVIRONMENT!!!

(function () {
    // binding info rule contains the selector and the binding (separated by the pipe: |).
    // selector refers to the control element which is used to lookup the element that matches the binding info

    var H4SM = Help4R.selector.methods;

    H4SM.BindingInfoUI5 = {
        safe: true,

        getElement: _getElement,
        getSelector: _getSelector
    };

    var CONTROLS = {
        table: ['getColumns'],
        filterbar: ['getFilterGroupItems', 'getFilterItems'],
        icontabbar: ['getSelectedKey']
    };

    function _getElement(selector) {
        if (typeof selector !== 'string' || selector.indexOf('|') &lt; 0) return null;

        var p = selector.split('|');
        if (p.length !== 2) return null;
        selector = null;

        var e = $(p[0]);
        var c = e &amp;&amp; typeof e.control === 'function' &amp;&amp; e.control();
        if (!c || c.length &lt; 1) return null;
        c = c[0];

        // get the control type for the selector (table, filterbar etc...)
        // and execute it's specific function
        var type = _getControlType(c);
        switch (type) {
            case 'table':
                selector = _getTableElement({ control: c, value: p[1] });
                break;
            case 'filterbar':
                selector = _getFilterbarElement({ control: c, value: p[1] });
                break;
            case 'icontabbar':
                selector = _getIcontabbarElement({ control: c, value: p[1] });
                break;
        }

        if (selector) {
            var el = $('#' + selector);
            return el &amp;&amp; el.length &gt; 0 ? el[0] : null;
        }

        return null;
    }

    function _getSelector(elem) {
        var domTree = H4SM.UtilsUI5.getDomTree(elem);
        if (domTree.length === 0) return null;

        var startIdx = H4SM.UtilsUI5.getIndexOfXmlView(domTree);
        var info = _getBindingControl(domTree, startIdx);
        if (!info || !info.control) return null;

        var s;
        switch (info.controlType) {
            case 'table':
                s = _getTableSelector({ control: info.control, element: elem });
                break;
            case 'filterbar':
                s = _getFilterbarSelector({ control: info.control });
                break;
            case 'icontabbar':
                s = _getIcontabbarSelector({ control: info.control });
                break;
        }

        return s
            ? info.node.selector + '|' + H4SM.UtilsUI5.filterId(s)
            : null;
    }

    function _getControlType(ctl) {
        // try to detect what kind of a control we are facing:
        // each control type supports specific functions as defined in CONTROLS above
        // if such a function exists on our control we know the type of the control

        for (var type in CONTROLS) {
            if (CONTROLS.hasOwnProperty(type)) {
                var c = CONTROLS[type];

                for (var i = 0, l = c.length; i &lt; l; i++) {
                    if (ctl[c[i]] !== undefined) return type;
                }
            }
        }

        return null;
    }

    function _getTableElement(params) {
        var cols = params.control.getColumns();

        for (var i = 0, l = cols.length; i &lt; l; i++) {
            // look at the control API for the columns
            var col = cols[i];

            if (col &amp;&amp; typeof col.getId === 'function' &amp;&amp; col.getId().match(params.value + '$')) {
                return col.getHeader().getId();
            }
        }

        return null;
    }

    function _getFilterbarElement(params) {
        // check first for Binding Info otherwise for Content Path (Control API)
        return _getBindingPathSelector(params) || _getContentPathSelector(params);
    }

    function _getIcontabbarElement(params) {
        if (typeof params.control.getItems === 'function') {
            var items = params.control.getItems();

            for (var i = 0, l = items.length; i &lt; l; i++) {
                var item = items[i];

                if (typeof item.getKey === 'function' &amp;&amp; item.getKey() === params.value) {
                    return item.getId();
                }
            }
        }

        return null;
    }

    function _getBindingPathSelector(params) {
        if (typeof params.control.getFilterGroupItems !== 'function' || typeof params.control.getFilterItems !== 'function') return null;

        var bindingTypes = ['value', 'dateValue'];

        var items = params.control.getFilterGroupItems();
        if (items.length === 0) items = params.control.getFilterItems();

        for (var i = 0, l = items.length; i &lt; l; i++) {
            var item = items[i];

            var labelCtl = typeof item.getLabelControl === 'function' ? item.getLabelControl() : null;
            if (!labelCtl || typeof labelCtl.getParent !== 'function') continue;

            var par = labelCtl.getParent();

            var bindings = par.mAggregations &amp;&amp; par.mAggregations.content &amp;&amp; par.mAggregations.content[1];
            var bInfo = bindings &amp;&amp; typeof bindings.getId === 'function' &amp;&amp; bindings.mBindingInfos || null;
            if (!bInfo) continue;

            for (var j = 0, l2 = bindingTypes.length; j &lt; l2; j++) {
                var bt = bindingTypes[j];
                var parts = bInfo[bt] &amp;&amp; bInfo[bt].parts || null;
                var path = parts &amp;&amp; parts[0] &amp;&amp; parts[0].path || null;

                if (path &amp;&amp; path.match(params.value + '$')) {
                    return bindings.getId();
                }
            }
        }

        return null;
    }

    function _getContentPathSelector(params) {
        if (typeof params.control.getFilterGroupItems !== 'function' || typeof params.control.getFilterItems !== 'function') return null;

        var items = params.control.getFilterGroupItems();
        if (items.length === 0) items = params.control.getFilterItems();

        for (var i = 0, l = items.length; i &lt; l; i++) {
            var item = items[i];

            var labelCtl = typeof item.getLabelControl === 'function' ? item.getLabelControl() : null;
            if (!labelCtl || typeof labelCtl.getId !== 'function' || typeof labelCtl.getParent !== 'function') continue;

            var par = labelCtl.getParent();

            var bindings = par.mAggregations &amp;&amp; par.mAggregations.content &amp;&amp; par.mAggregations.content[1];
            if (bindings &amp;&amp; typeof bindings.getId === 'function') {
                if (bindings.getId().match(params.value + '$')) {
                    return labelCtl.getId();
                }
            }
        }

        return null;
    }

    function _getBindingControl(domTree, startIdx) {
        // background: many UI5 controls are nested
        // e.g. icontabbar:
        // 1. icontabbar control +
        // (included) several tab controls

        // idea:
        // - traversing the DOM tree bottom up will 1st give us the specific control (e.g. the tab itself)
        // and going further up will lead us to the main control (the icontabbar)
        // - while single tabs might have non-stable IDs the icontabbar is expected to have a stable one
        // - so we search for the closest control (e.g. tab) (=&gt; ctl) as it really specifies the binding info
        // and continue to search bottom up in case it's ID is unstable until we find a stable ID
        // that is also a control (e.g. the icontabbar)

        var ctl = null;
        for (var i = domTree.length - 1; i &gt;= startIdx; i--) {
            var n = domTree[i];

            if (ctl === null &amp;&amp; n.id) {
                if (n.control === null) return null;  // no BindingInfo control

                // this is a BindingInfo control that is closest to our element
                // it can be used standalone in case it has a stable ID (see below)
                ctl = n.control;
            }

            // in case our ctl is using a stable ID: we can fully use it for recognition
            // in case ctl is using an unstable ID: we traverse up until we find another
            // control that is unique

            if (n.unique &amp;&amp; n.control) {
                var t = _getControlType(n.control);
                if (t) return { node: n, control: ctl, controlType: t };
            }
        }

        return null;
    }

    function _getTableSelector(params) {
        var c = params.control;

        var ci;
        var e = params.element;
        if (e.cellIndex != null) {
            ci = e.cellIndex;
        } else if (e.parentElement &amp;&amp; e.parentElement.cellIndex != null) {
            ci = e.parentElement.cellIndex;
        }
        if (ci === undefined) return null;

        // get visible and sorted columns to ensure to retrieve the correctly indexed item
        var cols = c.getColumns();
        var visCols = cols.filter(function (col) { return col.getVisible(); });
        var sortCols = visCols.sort(function (colA, colB) { return colA.getOrder() &gt; colB.getOrder(); });

        for (var i = 0, l = sortCols.length; i &lt; l; i++) {
            var col = sortCols[i];
            if (col._index === ci) {
                var cid = col.getId();
                if (cid.match(/__column/) === null) return cid;  // don't allow dynamic IDs
            }
        }

        return null;
    }

    function _getFilterbarSelector(params) {
        // use ID, or Binding path
        var c = params.control;
        var bInfo = c.mBindingInfos;

        if (bInfo &amp;&amp; bInfo.value || c.mBindParameters) {
            var vp = bInfo.value &amp;&amp; bInfo.value.parts;
            var dp = bInfo.dateValue &amp;&amp; bInfo.dateValue.parts;
            var vp0p = vp &amp;&amp; vp[0] &amp;&amp; vp[0].path;
            var dp0p = dp &amp;&amp; dp[0] &amp;&amp; dp[0].path;

            return vp0p || dp0p || c.getId();
        }

        return null;
    }

    function _getIcontabbarSelector(params) {
        var c = params.control;
        return typeof c.getKey === 'function' ? c.getKey() : null;
    }
})();

// include file: ../HTMLBasic/selector/methods/DomSelectorUI5.js

// NEVER FORGET: THIS CODE IS ALSO USED WITHIN WPB PRODUCER'S RECOGNITION ENGINE
// WITHIN PRODUCER THERE IS NO SUCH THINGS AS HOTSPOTS, ETC.
//
// MAKE SURE THAT THIS FILE AND ALL METHODS ARE ALWAYS SECURED TO RUN IN PRODUCER ENVIRONMENT!!!

(function () {
    var H4SM = Help4R.selector.methods;

    H4SM.DomSelectorUI5 = {
        safe: false,

        getElement: H4SM.Utils.getElement,
        getSelector: _getSelector
    };

    function _getSelector(elem) {
        var domTree = H4SM.UtilsUI5.getDomTree(elem);
        var domTreeL = domTree.length - 1;
        if (domTreeL &lt; 0) return null;

        // traverse from clicked element up the DOM until there is a unique element - use this as the starting point
        var startIdx = null;
        for (var i = domTreeL; i &gt;= 0; i--) {
            if (H4SM.$(domTree[i].selector).length === 1) {
                startIdx = i;
                break;
            }
        }
        if (startIdx === null) startIdx = H4SM.UtilsUI5.getIndexOfXmlView(domTree);

        var selector = domTree[startIdx].selector;

        // traverse down the DOM and add child position
        for (var i = startIdx, l = domTreeL; i &lt; l; i++) {
            selector += ' &gt; :nth-child(' + domTree[i + 1].position + ')';
        }

        // add position of original element within final container
        for (var i = 0, cn = domTree[domTreeL].element.children, l = cn.length; i &lt; l; i++) {
            if (cn[i] === elem) {
                selector += ' &gt; :nth-child(' + (i + 1) + ')';
                break;
            }
        }

        return selector || null;
    }
})();

// include file: script.js

/// &lt;reference path="../common/common_script.js/&gt;
/// &lt;reference path="../HTMLBasic/script.js/&gt;
/// &lt;reference path="../UI5_Library/script.js/&gt;
var gen_xray_path = false;

// =============================================
// part of UI5 or SAP Web?
// =============================================
var inner_delimiter = "##";
var outer_delimiter = "$$";
var frameIDs = ["URLS-PopupWindow-", "URLSPW-"];
var captionIDs = ["WDW0", "WDWL"];
// =============================================


DGO.SAPUI5Eep = function () {
    DGO.BaseEep.call(this);
};

DGO.SAPUI5Eep.prototype = new DGO.BaseEep();

extendObj(DGO.SAPUI5Eep.prototype, {

    toString: function () {
        if (this.eep_ori_) {
            return "Eep={path:\"" + this.path_ +
                   "\",opt:\"" + this.options_ +
                   "\",ori:\"" + this.eep_ori_ + "\"}";
        }

        return "Eep=" + DHtml_dumpObj(this);
    },
    valueOf: function () {
        return this.toString();
    }
});
var DgoEep = new DGO.SAPUI5Eep();
// ============================== Utils ===========================================
//DGO.SAPUI5Utils = function () {
//    DGO.Utils.call(this);
//}

//DGO.SAPUI5Utils.prototype = new DGO.Utils();

//extendObj(DGO.SAPUI5Utils.prototype, {
//});
var DgoUtils = new DGO.Utils();
// ============================== Processing ===========================================
DGO.SAPUI5Processing = function () {
    DGO.BaseProcessing.call(this);
};
DGO.SAPUI5Processing.prototype = new DGO.BaseProcessing();

extendObj(DGO.SAPUI5Processing.prototype, {
    get_context_attributes: function () {
        var context = get_active_tree_item();
        if (DgoUtils.is_valid_str(context)) {
            return "wacenwpb6818" + inner_delimiter + DgoUtils.trim(context) + outer_delimiter;
        }
        return "";
    }
});
var DgoProcessing = new DGO.SAPUI5Processing();
var role_exception_classes = ["sapMInputBaseIcon sapUiIcon sapUiIconMirrorInRTL sapUiIconPointer"];
// ============================== SAP UI 5 ===========================================
DGO.SAPUI5 = function () {
    DGO.HTMLBasic.call(this);
};
DGO.SAPUI5.prototype = new DGO.HTMLBasic();
extendObj(DGO.SAPUI5.prototype, DGO.UI5Library.prototype);
extendObj(DGO.SAPUI5.prototype, {
    correct_type: function(type, e) {
        type = DGO.HTMLBasic.prototype.correct_type.call(this, type, e);
        if (type === "button" &amp;&amp; DgoUtils.partial_search(e.className, role_exception_classes)) {
            type = "";
        } else if (type === "combobox" &amp;&amp; e.getAttribute("type") === "text") {
            type = "Edit";
        } else if (type === "radio" || type === "checkbox") {
            var html_rec_obj = HTMLElementRecognition.element_rect;
            if (html_rec_obj) {
                var width = parseInt(html_rec_obj.right) - parseInt(html_rec_obj.left);
                var height = parseInt(html_rec_obj.bottom) - parseInt(html_rec_obj.top);
                if (width &gt; (height * 1.5)) {
                    type = "labeltext";
                }
            }
        }
        return type;
    },
    check_handler: function (type) {
        var valid_sapui5_tags = [
            "LABELsapMSltLabel",
            "combobox",
            "Calendar",
            "SPANsapMInputBaseIcon sapUiIcon sapUiIconMirrorInRTL sapUiIconPointer",
            "LIsapMSelectListItem sapMSelectListItemHoverable",
            "LIsapMSelectListItem sapMSelectListItemHoverable sapMSelectListItemSelected"];
        return DgoUtils.is_in_array(type, valid_sapui5_tags) ||
            DgoUtils.is_in_array(type, DgoProfile.get_valid_roles()) ||
            DGO.UI5Library.prototype.check_handler.call(this, type) ||
            DGO.HTMLBasic.prototype.check_handler.call(this, type);
    },
    convert_to_compat: function (type) {
        switch (type) {
            case "LIsapMSelectListItem sapMSelectListItemHoverable":
                return "LIsapMSelectListItem sapMSelectListItemHoverable sapMSelectListItemSelected";
            case "LABELsapMSltLabel":
                return "LABELsapMSltLabel";
        }
        var new_type = DGO.UI5Library.prototype.convert_to_compat.call(this, type);
        return new_type !== type ? new_type : DGO.HTMLBasic.prototype.convert_to_compat.call(this, type);
    },
    elem_xtype: function (e) {
        var type = DGO.HTMLBasic.prototype.elem_xtype_from_role.call(this, e);
        if (!type) {
            if (!e) return "";
            var elem = e;
            var tagname = elem.tagName;
            var class_name = elem.className;
            type = tagname;
            var parent = elem.parentNode;
            var parentcn = parent.className;
            var parenttag = parent.tagName;

        if (DgoUtils.is_in_array(type, ["B", "U", "EM", "NOBR", "STRONG", "FONT"])) {
            if (parent !== null) {
                elem = parent;
                type = elem.tagName;
            }
        }

        switch (type) {
            case "INPUT":
                type += elem.type;
                tagname = type;
                var ntype = "";
                if (type === "INPUTimage") {
                    ntype = type + "/" + elem.id;
                    type += this.check_handler(ntype) ? "/" + elem.id : "/";
                }
                if (type === "INPUTimage/") {
                    ntype = type + "/" + parent.id;
                    type += this.check_handler(ntype) ? "/" + parent.id : "/";
                }
                if (type === "INPUTtext") type += class_name;
                break;
            case "IMG":
                type += parent.tagName;
                switch (type) {
                    case "IMGA":
                    case "IMGSPAN":
                        type += class_name + ":" + parentcn;
                        if (type === "IMGSPAN:WebguiToolbarIconEnabled") {
                            type += ":" + parent.id;
                            if (this.check_handler(type)) type = "IMGSPAN:WebguiToolbarIconEnabled";
                        }
                        break;
                    case "IMGTD":
                        type += class_name;
                        if (type === "IMGTD") type += parentcn;
                        var prev_sibling = elem.previousSibling;
                        if (type === "IMGTD" &amp;&amp; prev_sibling !== null) type += prev_sibling.tagName;
                        if (type === "IMGTDINPUT" &amp;&amp; prev_sibling !== null) type += prev_sibling.value;
                        if (type.match("IMGTDListItem*")) {
                            type = "IMGTDListItem";
                            var img = elem.href;
                            if (img.match("list.*2_5.*")) {
                                type += "-open";
                            } else if (img.match("list.*2_4.*")) {
                                type += "-closed";
                            } else if (img.match("list.*1_0.*")) {
                                type += "-leaf";
                            }
                            if (type === "IMGTDListItem") type = "IMGTDListItem-leaf"; // assume leaf for everything else
                        }
                        break;
                    case "IMGDIV":
                        if (type === "IMGDIV") type += class_name;
                        if (type === "IMGDIV") type += parentcn;
                        if (type === "IMGDIV") type += parent.id;
                        // Wertehilfe ist etwas anders in tabs und popups
                        if (type.match("IMGDIVwebguiTSSHButton.*") || type.match("IMGDIVwebguiConSHButton.*")) {
                            type = "IMGDIVwebguiSearchHelpButton";
                        }
                        break;
                    case "IMGLABEL":
                        type += class_name;
                        if (type === "IMGLABEL") type += parentcn;
                        break;
                }
                break;
            case "TD":
                type += class_name;

                if (type.match("TDListItem*")) {
                    type = "TDListItem";
                } else if (type.match("TDalvc.*")) {
                    type = "TDalvc";
                } else if (type.match("TDVSlider-*")) {
                    type = "TDVSlider";
                } else if (type.match("TDCalM.*")) {
                    type = "TDCalM";
                }

                // for TDsearchHelpResultBody
                if (type === "TD") type += parent.parentNode.parentNode.id;
                break;
            case "A":
                type += parentcn === "nwbc-HierarchicalBrowserFolderItem" ? parentcn : class_name;
                break;
            case "DIV":
                type += class_name;
                if (type === "DIV") type += elem.currentStyle.overflow;
                break;
            case "SPAN":
                var focus_class = "";
                if (class_name) {
                    type += class_name;
                } else if ((typeof elem.downclass !== "undefined" &amp;&amp; (focus_class = elem.downclass)) ||
                           (typeof elem.hoverclass !== "undefined" &amp;&amp; (focus_class = elem.hoverclass))) {
                    type += focus_class;
                }
                if (type.match("SPANCTLink.*")) {
                    type = "SPANCTLink";
                } else if (type === "SPAN") {
                    type += ":" + parentcn;
                }
                if (DgoUtils.element_has_classname(elem, "sapMInputBaseIcon sapUiIcon sapUiIconMirrorInRTL sapUiIconPointer")) {
                    if (elem.getAttribute("role") === "button") {
                        type = "combobox";
                    } else {
                        type = elem.getAttribute("data-sap-ui").search("BASIC-KeyDate-icon") != -1 ?
                               "Calendar" :                     
                               "SPANsapMInputBaseIcon sapUiIcon sapUiIconMirrorInRTL sapUiIconPointer";
                    }
                }
                break;
            case "LABEL":
            case "LI":
            case "EM":
            case "H3":
            case "H4":
            case "P":
            case "TH":
            case "BUTTON":
                type += class_name;
                break;
            case "BODY":
                if (typeof elem.contentEditable !== "undefined" &amp;&amp; elem.contentEditable === "true") type = "INPUTtexturPagerInput";
                break;
        }

        // do distinguish between SPANurTxtStd in certain TD from SPANurTxtStd in other or none TDs
        if (type === "SPANurTxtStd") {
            if (parentcn === "urSTTD urSTTDBdr2 urCursorClickable urSTSStd urSTCl") {
                type = "SPANurTxtStd_TDurSTTD urSTTDBdr2 urCursorClickable urSTSStd urSTCl";
            }
        }
        // to identify a checked checkbox
        if (type === "IMGLABELurCImgOn") {
            if (parentcn === "urCLbl urCl1") type = "cb_IMGLABELurCImgOn";
        }
        // to identify a unchecked checkbox
        if (type === "IMGLABELurCImgOff") {
            if (parentcn === "urCLbl urCl1") type = "cb_IMGLABELurCImgOff";
        }

        // InputFields in certain TDs for correct rect and fieldname
        if (type === "INPUTtexturEdf2TxtEnbl") {
            if (parenttag === "TD") type = "INPUTurEdf2TxtEnbl_in_TD";
        }
        type = DgoUtils.trim(type);

        // fallback to tagname if no special entry found
        if (!this.check_handler(type)) {
            switch (tagname) {
                case "A":
                case "BUTTON":
                case "OPTION":
                case "INPUTtext":
                case "TEXTAREA":
                case "DIV":
                    type = tagname;
                    break;
                case "IMG":
                    type = "IMGA:";
                    break;
                case "SPAN":
                    type = "A";
                    break;
                case "BODY":
                case "HTML":
                    break;
                default:
                    type = "A";
                    break;
            }
        }

            type = this.convert_to_compat(type);
        }
        //alert(type);
        //alert(e.outerHTML);
        return type;
    },
    get_text_from_child: function (e) {
        try {
            var labelledby = e.getAttribute("aria-labelledby");
            if (labelledby) {
                var doc = this.get_doc_from_elem(e);
                var labelelm = doc.getElementById(labelledby);
                if (labelelm) return labelelm.innerText;
            }
            var parent = e.parentNode;
            if (!parent) return "";

            var label_coll = parent.getElementsByTagName("LABEL");
            var count = label_coll.length;
            if (0 === count) {
                if (!parent.parentElement) return "";

                label_coll = parent.parentElement.getElementsByTagName("LABEL");
                count = label_coll.length;
                if (0 === count) return "";
            }
            for (var i = 0; i &lt; count; i++) {
                var child_elem = label_coll[i];
                var child_id = child_elem.htmlFor;
                if (child_id === e.id || child_id === e.name) return child_elem.innerText;
            }
        } catch (err) { exception_debugging(err); }
        return "";
    },
    is_valid_control_tagname: function (e) {
        try {
            if (e &amp;&amp; e.tagName == "HEADER") return true;
        } catch (err) { exception_debugging(err); }
        return DGO.Base.prototype.is_valid_control_tagname.call(this, e);
    },
    get_tooltip: function (e) {
        try {
            if (!e) return "";
            if (typeof e.id !== "undefined") {
                var id = e.id.substr(0, e.id.indexOf("-"));
                var parent = document.getElementById(id);
                if (parent &amp;&amp; parent.title) {
                    return parent.title;
                } else if (parent = document.getElementById(id + "-text")) {
                    return parent.innerText;
                }
            }
            if (DgoUtils.is_valid_str(e.title)) {
                return e.title;
            }
        } catch (err) { exception_debugging(err); }
        return "";
    },
    inner_text: function (e) {
        try {
            if (e) {
                if (e.tagName === "B" &amp;&amp; e.parentElement) {
                    var inner = e.parentElement.innerText;
                    if (typeof inner !== "undefined") return inner;
                }
                return typeof e.innerText !== "undefined" &amp;&amp; e.innerText ?
                e.innerText : this.get_tooltip(e);
            }
        } catch (err) { exception_debugging(err); }
        return "";
    },
    button_name: function (e) {
        var name = "";
        try {
            if (e) {
                if (e.title &amp;&amp; e.title.length &gt; 0) {
                    name = e.title;
                } else if (e.alt &amp;&amp; e.alt.length &gt; 0) {
                    name = e.alt;
                } else {
                    name = this.get_tooltip(e);
                }
            }
        } catch (err) { exception_debugging(err); }

        return typeof name !== "undefined" ? name : "";
    }
});
var DgoProfile = new DGO.SAPUI5();
// -----------------------------------------------------------------
DGO.SAPUI5HTMLElementRecognition = function () {
    DGO.SAPUI5LibHTMLElementRecognition.call(this);
};

DGO.SAPUI5HTMLElementRecognition.prototype = new DGO.SAPUI5LibHTMLElementRecognition();

extendObj(DGO.SAPUI5HTMLElementRecognition.prototype, {
    xray_path: "",
    path_safe: 1,
    get_element_from_point: function (point_x, point_y) {
        try {
            var get_elem = DGO.SAPUI5LibHTMLElementRecognition.prototype.get_element_from_point.call(this, point_x, point_y);
            if (!this.has_role) {
                var client_x = point_x;
                var client_y = point_y;
                if (Math.abs(dgo_zoomlevel - 100) &gt; 4) {
                    client_x = Math.ceil(client_x * 100 / dgo_zoomlevel);
                    client_y = Math.ceil(client_y * 100 / dgo_zoomlevel);
                }
                if (!(this.element = window.document.elementFromPoint(client_x, client_y))) return false;
                this.element = DgoProfile.check_accessKey(this.element);
                if (this.element &amp;&amp; this.element.tagName === "B") this.element = this.element.parentElement;
                // xray
                var aElements = (typeof $ === "function" &amp;&amp; typeof $.fn === "object") ? $(this.element).closest(".sapUshellTile") : null;            
                
                if (aElements &amp;&amp; aElements[0] !== undefined &amp;&amp; aElements[0].tagName !== undefined) {
                    this.element = aElements[0];
                }
            }
            try {
                if (typeof sap !== "undefined" &amp;&amp; typeof sap.ui !== "undefined" &amp;&amp; gen_xray_path) {
                    var wpb_xray = generate_xray_path(this.element, Help4R.RpickSelector().selector);  // xRay.js
                    if (DgoUtils.is_valid_str(wpb_xray.rule)) {
                        window.document.body.setAttribute("wpb_xray_hotspotAnchor", wpb_xray.rule, 0);
                        this.xray_path = "xray=\"" + window.btoa(JSON.stringify(wpb_xray.rule)) + "\";xps=\"" + wpb_xray.safe + "\";";
                        this.path_safe = wpb_xray.safe;
                        this.element = wpb_xray.elem;
                    }
                }
            } catch (err) {
                exception_debugging(err);
            }
            
            if (!this.has_role) {
                var parent_role = this.element.parentNode.getAttribute("role");
                if (parent_role &amp;&amp; typeof parent_role !== "undefined") {
                    if (this.element.previousSibling &amp;&amp; this.element.previousSibling.tagName === "INPUT") {
                        this.element = this.element.previousSibling;
                    }
                }
            }
            return get_elem;
        } catch (err) { exception_debugging(err); }
        return false;
    },
    correct_bc_rect: function () {
        if (this.element.tagName === "INPUT" &amp;&amp; this.element.className === "sapMSFI" &amp;&amp; this.element.getAttribute("type") === "search") {
            var parent = this.element.parentNode;
            var new_rect = DgoProfile.offset_rect(parent.getBoundingClientRect(), this.frame_offset_x, this.frame_offset_y);
            var last_child = parent.lastChild;
            if (DgoUtils.element_has_classname(last_child, 'sapMSFB sapMSFS')) {
                var search_rect = last_child.getBoundingClientRect();
                new_rect.right = parseInt(search_rect.left);
                this.element_rect = DgoProfile.offset_rect(new_rect, this.frame_offset_x, this.frame_offset_y);
                return true;
            }
        }
        var role = DgoUtils.get_role(this.element);            
        if (role === "checkbox" || role === "radio") {
            var elm_rect = this.element_rect;
            var height = parseInt(elm_rect.bottom) - parseInt(elm_rect.top);

            var rect_left = DgoProfile.offset_rect(elm_rect, 0, 0);
            rect_left.left = parseInt(rect_left.right) - parseInt(height - 5);
            if (this.pt_in_rect(this.client_x, this.client_y, rect_left)) {
                this.element_rect = DgoProfile.offset_rect(rect_left, this.frame_offset_x, this.frame_offset_y);
                return true;
            }
            
            var rect_right = DgoProfile.offset_rect(elm_rect, 0, 0);
            rect_right.right = parseInt(rect_right.left) + parseInt(height - 5);
            if (this.pt_in_rect(this.client_x, this.client_y, rect_right)) {
                this.element_rect = DgoProfile.offset_rect(rect_right, this.frame_offset_x, this.frame_offset_y);
                return true;
            }
        }
        return false;
    },
    recognition_output: function () {
        var obj_rect = "";
        if (this.object_sub_type === "") {
            obj_rect = this.element_rect.left + "," + this.element_rect.top + "," +
                      this.element_rect.right + "," + this.element_rect.bottom;
        } else {
            obj_rect = this.element_rect_str;
        }
        var prop = DgoProfile.get_properties(this.element);
        return ("epath|=|" + this.element_path + delimiter + "type|=|" + this.object_type +
            delimiter + "rect|=|" + obj_rect + delimiter + "eep|=|" + this.eep + this.xray_path + delimiter +
            "name|=|" + prop.name + delimiter + "val|=|" + prop.value + delimiter +
            "safe|=|" + this.path_safe);
    },
    pt_in_rect: function(x, y, rect) {
        return (x &gt;= parseInt(rect.left) &amp;&amp;
                x &lt;= parseInt(rect.right) &amp;&amp;
                y &gt;= parseInt(rect.top) &amp;&amp;
                y &lt;= parseInt(rect.bottom));
    }

});

var HTMLElementRecognition = new DGO.SAPUI5HTMLElementRecognition();

DGO.SAPUI5HTMLElementRerecognition = function () {
    DGO.BaseHTMLElementRerecognition.call(this);
};

DGO.SAPUI5HTMLElementRerecognition.prototype = new DGO.BaseHTMLElementRerecognition();

extendObj(DGO.SAPUI5HTMLElementRerecognition.prototype, {
    rerecognition_output: function () {
        var obj_rect = "";
        if (this.object_sub_type === "") {
            obj_rect = this.element_rect.left + "," + this.element_rect.top + "," +
                      this.element_rect.right + "," + this.element_rect.bottom;
        } else {
            obj_rect = this.element_rect_str;
        }
        var prop = DgoProfile.get_properties(this.element);

        return ("type=" + this.object_type + delimiter + "rect=" + obj_rect + delimiter + "epath=" + this.element_path + delimiter + "name|=|" + prop.name + delimiter + "val|=|" + prop.value);
        //delimiter + this.rerecognition_eep_frame + delimiter + prop.name + delimiter + prop.value);
    }
});
var HTMLElementRerecognition = new DGO.SAPUI5HTMLElementRerecognition();
//-----------------------------------------Hover Effect--------------------------------------------------//
DGO.SAPUI5Effect = function () {
    DGO.Effect.call(this);
};
DGO.SAPUI5Effect.prototype = new DGO.Effect();

extendObj(DGO.SAPUI5Effect.prototype, {
    mouse_effect_handler: function (e) {
        try {
            e = e || event;
            if (!e || !e.target) return;

            if (e.type === "mouseover") {
                //console.log("mouseover effect");
                if (DgoEffect.overlay.active === false) return;
                var p = generate_xray_path(e.target, Help4R.RpickSelector().selector);  // xRay.js
                var target_pos = (p &amp;&amp; p.elem) ? p.elem.getBoundingClientRect() : e.target.getBoundingClientRect();

                var overlay_style = DgoEffect.get_overlay().style;
                overlay_style.cssText = _HELP4_CONTROL_CAPTURERECT_CSS + ((p &amp;&amp; p.safe === 1.0) ? _HELP4_SAFE_CSS : "");
                overlay_style.visibility = "";
                overlay_style.left = target_pos.left.toString() + "px";
                overlay_style.top = target_pos.top.toString() + "px";
                overlay_style.width = (target_pos.right - target_pos.left).toString() + "px";
                overlay_style.height = (target_pos.bottom - target_pos.top).toString() + "px";

                //console.log("over " + e.target.tagName + ":" + e.target.className + " pos: " + target_pos.left + "x" + target_pos.top + ((p &amp;&amp; p.elem) ? " (selector element)" : " (event target)"));
                //console.log("effect active: " + DgoEffect.overlay.active + " timestamp: " + DgoEffect.overlay.timestamp);
                //console.log("rule: " + p.rule.toString());
                //console.log("selector: " + Help4R.RpickSelector().name);   // xRay.js

                // prevent other mouseover effects
                e.cancelBubble = true;
            }
        } catch (err) { exception_debugging(err); console.log(err.stack); }
    }

});
var DgoEffect = DgoEffect || new DGO.SAPUI5Effect();
//var DgoEffect = DgoEffect || new DGO.Effect();
//-----------------------------------------Page Key--------------------------------------------------//
var pagekey_delimiter = "|@|";

function get_active_page_tab() {
    var pgkey = "";
    try {
        pgkey = get_first_header("DialogTitle", true);
        if (DgoProfile.valid_string(pgkey)) return pgkey;
        pgkey = get_active_dlg();
    } catch (err) { exception_debugging(err); }
    return pgkey;
}

function get_first_header(headerClass, dialog) {
    var coll = window.document.getElementsByTagName("HEADER");
    var len = coll.length;
    var header_text = "";
    for (var iter = 0; iter &lt; len; iter++) {
        var elem = coll[iter];
        var elmstyle = elem.currentStyle ? elem.currentStyle : elem.style;
        if (elmstyle &amp;&amp; elmstyle.visibility !== "hidden" &amp;&amp;
        elem.className &amp;&amp; is_valid_header(elem, headerClass, dialog)) {
            var doc = DgoProfile.get_doc_from_elem(elem);
            if (doc) {
                var elem_offset = DgoProfile.get_elem_offset(elem);
                if (elem.offsetWidth === 0) continue;
                var ctl_middle_x = elem_offset.l + elem.offsetWidth / 2;
                var ctl_middle_y = elem_offset.t + elem.offsetHeight / 2;
                var middle_ctl = doc.elementFromPoint(ctl_middle_x, ctl_middle_y);
                if (middle_ctl) {
                    header_text = middle_ctl.innerText;
                    if (DgoProfile.valid_string(header_text)) break;
                }
            }
            header_text = elem.innerText;
            if (!DgoProfile.valid_string(header_text)) continue;
            break;
        }
    }
    return header_text.trim();
}

function is_valid_header(elem, headerClass, dialog) {
    var valid_header = false;

    if (elem.className.search(headerClass) !== -1) valid_header = true;
    if (dialog &amp;&amp; !valid_header) {
        var sec_elm = typeof $ === "function" ? $(elem).closest("SECTION") : null;
        if (sec_elm &amp;&amp; sec_elm[0] &amp;&amp; sec_elm[0].className &amp;&amp;
            (sec_elm[0].className.search("DialogSection") !== -1)) {
            valid_header = true;
        }
    }
    return valid_header;
}

function get_active_tree_item() {
    var key = "";
    try {
        if (typeof sap !== "undefined" &amp;&amp; typeof sap.ushell !== "undefined") {
            key = _getScreenId();
        } else {
            key = get_first_header("PageHeader", false);
        }
        if (!DgoProfile.valid_string(key)) {
            key = substring_counted_endtoken(document.URL, "#", "/", 2);
        }
    } catch (err) { exception_debugging(err); }
    return DgoProfile.valid_string(key) ? key : "";
}

function substring_counted_endtoken(str, startToken, endToken, count) {
    try {
        var start_pos = str.indexOf(startToken);
        if (-1 === start_pos) return "";
        var end_pos = start_pos;
        for (var iter = 0; iter &lt; count; iter++) {
            end_pos = str.indexOf(endToken, end_pos + 1);
            if (-1 === end_pos) {
                var len = str.length;
                var str_end = str.substring(len - 2, len);
                end_pos = str_end === "&amp;/" ? len - 2 : len;
                break;
            }
        }
        var res = str.substring(start_pos + 1, end_pos);
        return res;
    } catch (err) { exception_debugging(err); }
    return "";
}

function get_active_dlg() {
    var pgkey = "";
    try {
        var dlgs = DgoUtils.get_element_by_classname(document, "dialog-shield");
        if (dlgs !== null &amp;&amp; dlgs.length) {
            var count = dlgs.length - 1;
            for (var iter = count; iter &gt;= 0; iter--) {
                var lis = dlgs[iter];
                if (!DgoProfile.is_obj_hidden(lis)) {
                    var h2_coll = lis.getElementsByTagName("h2");
                    if (h2_coll !== null &amp;&amp; h2_coll.length) {
                        pgkey = h2_coll[0].innerText;
                    }
                    break;
                }
            }
        }
    } catch (err) { exception_debugging(err); }
    return DgoUtils.trim(pgkey);
}

//-------------------------------------------------------------------------------------------------//

</GlobalScript>
        </HTML3>
        <DIG generate_path="0" generate_triangle="1">
            <Settings>
                <CParams min_object_height="8" min_object_width="8">
                    <ClusterParams epsh="4" epsv="6" min_pts="2" max_cl_size="20"/>
                    <ClusterParams epsh="15" epsv="1" min_pts="1" max_cl_size="20"/>
                    <ClusterParams epsh="10" epsv="1" min_pts="10" max_cl_size="20"/>
                    <ClusterParams epsh="10" epsv="1" min_pts="11" max_cl_size="16"/>
                </CParams>
                <RParams max_gap="1" min_line_length="10" threshold="30"/>
                <CiParams circle_threshold="0.700000" inner_threshold="0.650000" outer_threshold="0.670000"/>
            </Settings>
            <PointAnalyzing all="0" analyze_width="50" analyze_height="250" merge_cross_objects="0"/>
            <Contexts>
                <Context type="menubar" max_hor_inter_obj_dist="30" max_vert_inter_obj_dist="10" top_min_dist="15" top_max_dist="70">
                    <ObjectSize>
                        <WidthRange min="9" max="300"/>
                        <HeightRange min="8" max="25"/>
                    </ObjectSize>
                    <Alignment type="center" direction="horizontal" maxdiff="3"/>
                    <Alignment type="left" direction="vertical" maxdiff="1"/>
                </Context>
            </Contexts>
        </DIG>
        <SAPB1 generate_path="1" analyze_point_timeout="3000" get_pagekey_timeout="7000"/>
        <GRAPHIC>
            <SupportedDesigns>
                <Design name="All" SupportedColorResolutions="24,32" SupportedFontSmoothing="" cleartype_ie="nocheck"/>
            </SupportedDesigns>
        </GRAPHIC>
    </Global>
</CTHeader>